{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-\\.]+"},"docs":[{"location":"","text":"Profil Nama : Galih Restu Baihaqi Nim : 190411100177 Kelas : Komputasi Numerik A Prodi : Teknik Informatika Universitas Trunojoyo Madura","title":"Home"},{"location":"Algoritma-Gauss-Jordan/","text":"Algoritma Metode Gauss Jordan \u00b6 Masukkan matrix A dan juga vektor B dengan ukurannya Membuat matrix [A|B] dan berikan nama A pada baris ke i, i = 1 s/d n, ketika a sama dengan 0. baris ke i ditukar ke i+k<=n, lalu, ketika diagonalnya satu, maka pada setiap kolom lakukan $$ a_{i,k}= \\dfrac {a_i,k}{a_{i,j}} $$ namun ketika tidak, lanjutkan pada baris ke j, j = i + 1 s/d n, melakukan operasi elementer ketika kolom k = 1 s/d n hitunglah : $$ \\begin{aligned} c = a_{j,i} \\ a_{j,k} = a_{j,k} - c.a_{i,k} \\end{aligned} $$ penyelesaiannya ketika i = n s/d 1, lakukan persamaan : $$ \\begin {aligned} x_{1} = d_{1} \\ x_{2} = d_{2} \\ x_{3} = d_{3} \\ x_{n} = d_{n} \\end{aligned} $$","title":"Algoritma Gauss Jordan"},{"location":"Algoritma-Gauss-Jordan/#algoritma_metode_gauss_jordan","text":"Masukkan matrix A dan juga vektor B dengan ukurannya Membuat matrix [A|B] dan berikan nama A pada baris ke i, i = 1 s/d n, ketika a sama dengan 0. baris ke i ditukar ke i+k<=n, lalu, ketika diagonalnya satu, maka pada setiap kolom lakukan $$ a_{i,k}= \\dfrac {a_i,k}{a_{i,j}} $$ namun ketika tidak, lanjutkan pada baris ke j, j = i + 1 s/d n, melakukan operasi elementer ketika kolom k = 1 s/d n hitunglah : $$ \\begin{aligned} c = a_{j,i} \\ a_{j,k} = a_{j,k} - c.a_{i,k} \\end{aligned} $$ penyelesaiannya ketika i = n s/d 1, lakukan persamaan : $$ \\begin {aligned} x_{1} = d_{1} \\ x_{2} = d_{2} \\ x_{3} = d_{3} \\ x_{n} = d_{n} \\end{aligned} $$","title":"Algoritma Metode Gauss Jordan"},{"location":"Algoritma-Metode-Dekomposisi-LU/","text":"Algoritma Metode Dekomposisi LU \u00b6 Memasukkan matrix A, beserta Vektor B beserta ukurannya n Poin ke - 4 s/d ke - 5 agar mendapatkan matrix U Pada baris ke - i, ketika i = 1 sampai n, lihat nilai \\(a_{i,j}\\) = 0 Ketika pada baris ke - j = 1 + 1 sampai n, lakukan baris elementer Hitung : $$ c = \\dfrac {a_{j,i}} {a_{i,i}} $$ ketika kolom k = 1 sampai n + 1, hitung : $$ a_{j,k} = a_{j,k} - c_{i}.a_{i,k} $$ Agar mendapatkan diagonal L, diisi dengan nilai 1 dan element di atas dengan nilai 0 Pada element dibawahnya diisi dengan pengali operasi baris berelementer matrix U lakukan forward substitusion untuk memperoleh nilai t : \\(t_{i}=b_{i}-\\Sigma^{i-1}_{j=1}l_{i,j}t_{i}\\) backward substitution dengan : $$ x_{n} = \\dfrac{d_{n}}{c_{m.n}} $$ $$ x_{n-1} = \\dfrac{1}{c_{m-1.n-1}}(d_{n-1}-c_{m-1.n}x_{n}) $$ $$ x_{2}= \\dfrac{1}{c_{2.2}}(d_{2} - {c_{2.2}x_{3}}- {c_{2.4}x_{4}-{c_{2.n}x_{n}}}) $$ $$ x_{2}= \\dfrac{1}{c_{1.1}}(d_{1} -{c_{1.2}x_{2}}- {c_{1.3}x_{3}-{c_{1.n}x_{n}}}) $$","title":"Algoritma Dekomposisi LU"},{"location":"Algoritma-Metode-Dekomposisi-LU/#algoritma_metode_dekomposisi_lu","text":"Memasukkan matrix A, beserta Vektor B beserta ukurannya n Poin ke - 4 s/d ke - 5 agar mendapatkan matrix U Pada baris ke - i, ketika i = 1 sampai n, lihat nilai \\(a_{i,j}\\) = 0 Ketika pada baris ke - j = 1 + 1 sampai n, lakukan baris elementer Hitung : $$ c = \\dfrac {a_{j,i}} {a_{i,i}} $$ ketika kolom k = 1 sampai n + 1, hitung : $$ a_{j,k} = a_{j,k} - c_{i}.a_{i,k} $$ Agar mendapatkan diagonal L, diisi dengan nilai 1 dan element di atas dengan nilai 0 Pada element dibawahnya diisi dengan pengali operasi baris berelementer matrix U lakukan forward substitusion untuk memperoleh nilai t : \\(t_{i}=b_{i}-\\Sigma^{i-1}_{j=1}l_{i,j}t_{i}\\) backward substitution dengan : $$ x_{n} = \\dfrac{d_{n}}{c_{m.n}} $$ $$ x_{n-1} = \\dfrac{1}{c_{m-1.n-1}}(d_{n-1}-c_{m-1.n}x_{n}) $$ $$ x_{2}= \\dfrac{1}{c_{2.2}}(d_{2} - {c_{2.2}x_{3}}- {c_{2.4}x_{4}-{c_{2.n}x_{n}}}) $$ $$ x_{2}= \\dfrac{1}{c_{1.1}}(d_{1} -{c_{1.2}x_{2}}- {c_{1.3}x_{3}-{c_{1.n}x_{n}}}) $$","title":"Algoritma Metode Dekomposisi LU"},{"location":"Algoritma-Metode-Euler/","text":"Algoritma Metode Euler \u00b6 Menentukan titik awal dari sebuah integrasi x0 dan y0 Menentukan Jumlah iterasi pada n dan h yang akan digunakan Lalu, lakukan Integrasi menggunakan rumus $$ y_{i+1}=y_{i}(x_{i},y_{i})h $$","title":"Algoritma Euler"},{"location":"Algoritma-Metode-Euler/#algoritma_metode_euler","text":"Menentukan titik awal dari sebuah integrasi x0 dan y0 Menentukan Jumlah iterasi pada n dan h yang akan digunakan Lalu, lakukan Integrasi menggunakan rumus $$ y_{i+1}=y_{i}(x_{i},y_{i})h $$","title":"Algoritma Metode Euler"},{"location":"Algoritma-Metode-Heun/","text":"Algoritma Metode Heun \u00b6 Menentukan titik awal pada integrasi x0 dan y0 Menentukan total iterasi n dan h yang akan digunakan Memprediksi nilai awal dengan rumus = \\(y^{0}_{i+1} = y_{i}+f(x_{i} , y_{i})\\) Mengkoreksi nilai awal dengan rumus $$ y_{i+1}=y_{i}+\\dfrac{f(x_{i},y_{i})+f(x_{i+1},y^{0}_{i+1})}{2}h $$ Mengkoreksi nilai yang dari hasil koreksi sebelumnya menggunakan rumus $$ y_{i+1}=y_{i}+\\dfrac{f(x_{i},y_{i})+f(x_{i+1},y^{0}_{i+1})}{2}h $$","title":"Algoritma Heun"},{"location":"Algoritma-Metode-Heun/#algoritma_metode_heun","text":"Menentukan titik awal pada integrasi x0 dan y0 Menentukan total iterasi n dan h yang akan digunakan Memprediksi nilai awal dengan rumus = \\(y^{0}_{i+1} = y_{i}+f(x_{i} , y_{i})\\) Mengkoreksi nilai awal dengan rumus $$ y_{i+1}=y_{i}+\\dfrac{f(x_{i},y_{i})+f(x_{i+1},y^{0}_{i+1})}{2}h $$ Mengkoreksi nilai yang dari hasil koreksi sebelumnya menggunakan rumus $$ y_{i+1}=y_{i}+\\dfrac{f(x_{i},y_{i})+f(x_{i+1},y^{0}_{i+1})}{2}h $$","title":"Algoritma Metode Heun"},{"location":"Algoritma-Metode-Runge-Kutta/","text":"Algoritma Metode Runge-Kutta Orde 4 \u00b6 Menentukan titik awal dari sebuah integrasi x0 dan y0 Menentukan Jumlah iterasi pada n dan h yang akan digunakan Lalu, lakukan Integrasi menggunakan rumus $$ y_{i+1}=y_{i}+\\dfrac{1}{0}(k_{1}+2k_{2}+2k_{3}+k_{4})h $$","title":"Algoritma Runge - Kutta"},{"location":"Algoritma-Metode-Runge-Kutta/#algoritma_metode_runge-kutta_orde_4","text":"Menentukan titik awal dari sebuah integrasi x0 dan y0 Menentukan Jumlah iterasi pada n dan h yang akan digunakan Lalu, lakukan Integrasi menggunakan rumus $$ y_{i+1}=y_{i}+\\dfrac{1}{0}(k_{1}+2k_{2}+2k_{3}+k_{4})h $$","title":"Algoritma Metode Runge-Kutta Orde 4"},{"location":"Algoritma-Metode-Tengah/","text":"Algoritma Metode Titik Tengah \u00b6 Menentukan Titik awal x0 dan y0 Menentukan total iterasi n dan step size Melakukan integrasi disetengah tahapan iterasi dengan rumus $$ y_{i+0,5} = y_{i}+f(x_{i},y_{i})\\dfrac{h}{2} $$ Melakukan iterasi disetengah tahap kelanjutannya dengan rumus $$ y_{i+0,5}=y_{i}+f(x_{i+0,5},y_{i+0,5})h $$","title":"Algoritma Titik Tengah"},{"location":"Algoritma-Metode-Tengah/#algoritma_metode_titik_tengah","text":"Menentukan Titik awal x0 dan y0 Menentukan total iterasi n dan step size Melakukan integrasi disetengah tahapan iterasi dengan rumus $$ y_{i+0,5} = y_{i}+f(x_{i},y_{i})\\dfrac{h}{2} $$ Melakukan iterasi disetengah tahap kelanjutannya dengan rumus $$ y_{i+0,5}=y_{i}+f(x_{i+0,5},y_{i+0,5})h $$","title":"Algoritma Metode Titik Tengah"},{"location":"Kode-Integrasi-numerik/","text":"Simpson 1/3 \u00b6 def f ( x ): return 1 / ( 1 + x ** 2 ) def simpson13 ( x0 , xn , n ): h = ( xn - x0 ) / n integrasi = f ( x0 ) + f ( xn ) for i in range ( 1 , n ): k = x0 + i * h if i % 2 == 0 : integrasi = integrasi + 2 * f ( k ) else : integrasi = integrasi + 4 * f ( k ) integrasi = integrasi * h / 3 return integrasi nilai_bawah = float ( input ( \"Batas bawah integrasi : \" )) nilai_atas = float ( input ( \"Batas atas integrasi : \" )) nilai_interval = int ( input ( \"Masukkan jumlah Interval : \" )) nilai = simpson13 ( nilai_bawah , nilai_atas , nilai_interval ) print ( \"Nilai dari integrasi Simpson 1/3 adalah : %0.6f \" % ( nilai ) ) Outputnya: Batas bawah integrasi : 1 Batas atas integrasi : 5 Masukkan jumlah Interval : 2 Nilai dari integrasi Simpson 1/3 adalah : 0.625641 Penjelasan Code : membuat nilai inputan batas bawah dari integrasi tersebut, dan membuat inputan batas atas dari integrasi tersebut juga. lalu juga membuat intervalnya. f adalah fungsi dengan sebuah parameter x. yang akan mengembalikan nilai dari 1/x(pangkat2). x0,xn dan n adalah parameter dalam fungsi simpson13 , x0 yang akan menangkap nilai dari batas bawah, lalu xn dari nilai batas atas dan juga n yang menangkap nilai dari interval. kemudian h adalah variable yang akan menampung hasil kurang dari nilai bawah dan atas yang kemudian di bagi oleh nilai interval. kemudian membuat loopingan yang dibulai dari 1 sampai n. k adalah vaiable dengan nilai x0 yang di jumlahkan dengan inialisasi loopingan yang kemudian di kalikan dengan hasil h lalu, akan di buat percabangan yang kondisinya di modulus 2. kemudian nilai dari integrasi dibagi 3 karena ini merupakan simpson 1/3. Simpson 3/8 \u00b6 def f ( x ): return 1 / ( 1 + x ** 2 ) def simpson38 ( x0 , xn , n ): h = ( xn - x0 ) / n integrasi = f ( x0 ) + f ( xn ) for i in range ( 1 , n ): k = x0 + i * h if i % 2 == 0 : integrasi = integrasi + 2 * f ( k ) else : integrasi = integrasi + 3 * f ( k ) integrasi = integrasi * 3 * h / 8 return integrasi nilai_bawah = float ( input ( \"Batas bawah integrasi : \" )) nilai_atas = float ( input ( \"Batas atas integrasi : \" )) nilai_interval = int ( input ( \"Masukkan jumlah Interval : \" )) nilai = simpson38 ( nilai_bawah , nilai_atas , nilai_interval ) print ( \"Nilai dari integrasi Simpson 3/8 adalah : %0.6f \" % ( nilai ) ) Outputnya: Batas bawah integrasi : 1 Batas atas integrasi : 5 Masukkan jumlah Interval : 2 Nilai dari integrasi Simpson 3/8 adalah : 0.628846 Penjelasan Code : Penjelasannya juga tidak jauh beda dari simpson 1/3 membuat nilai inputan batas bawah dari integrasi tersebut, dan membuat inputan batas atas dari integrasi tersebut juga. lalu juga membuat intervalnya. f adalah fungsi dengan sebuah parameter x. yang akan mengembalikan nilai dari 1/x(pangkat2). x0,xn dan n adalah parameter dalam fungsi simpson13 , x0 yang akan menangkap nilai dari batas bawah, lalu xn dari nilai batas atas dan juga n yang menangkap nilai dari interval. kemudian h adalah variable yang akan menampung hasil kurang dari nilai bawah dan atas yang kemudian di bagi oleh nilai interval. kemudian membuat loopingan yang dibulai dari 1 sampai n. k adalah vaiable dengan nilai x0 yang di jumlahkan dengan inialisasi loopingan yang kemudian di kalikan dengan hasil h lalu, akan di buat percabangan yang kondisinya di modulus 2. kemudian nilai dari integrasi dikali 3 dan dikalikan juga dengan n ilai h lalu dibagi 3 karena ini merupakan simpson 3/8.","title":"Kode"},{"location":"Kode-Integrasi-numerik/#simpson_13","text":"def f ( x ): return 1 / ( 1 + x ** 2 ) def simpson13 ( x0 , xn , n ): h = ( xn - x0 ) / n integrasi = f ( x0 ) + f ( xn ) for i in range ( 1 , n ): k = x0 + i * h if i % 2 == 0 : integrasi = integrasi + 2 * f ( k ) else : integrasi = integrasi + 4 * f ( k ) integrasi = integrasi * h / 3 return integrasi nilai_bawah = float ( input ( \"Batas bawah integrasi : \" )) nilai_atas = float ( input ( \"Batas atas integrasi : \" )) nilai_interval = int ( input ( \"Masukkan jumlah Interval : \" )) nilai = simpson13 ( nilai_bawah , nilai_atas , nilai_interval ) print ( \"Nilai dari integrasi Simpson 1/3 adalah : %0.6f \" % ( nilai ) ) Outputnya: Batas bawah integrasi : 1 Batas atas integrasi : 5 Masukkan jumlah Interval : 2 Nilai dari integrasi Simpson 1/3 adalah : 0.625641 Penjelasan Code : membuat nilai inputan batas bawah dari integrasi tersebut, dan membuat inputan batas atas dari integrasi tersebut juga. lalu juga membuat intervalnya. f adalah fungsi dengan sebuah parameter x. yang akan mengembalikan nilai dari 1/x(pangkat2). x0,xn dan n adalah parameter dalam fungsi simpson13 , x0 yang akan menangkap nilai dari batas bawah, lalu xn dari nilai batas atas dan juga n yang menangkap nilai dari interval. kemudian h adalah variable yang akan menampung hasil kurang dari nilai bawah dan atas yang kemudian di bagi oleh nilai interval. kemudian membuat loopingan yang dibulai dari 1 sampai n. k adalah vaiable dengan nilai x0 yang di jumlahkan dengan inialisasi loopingan yang kemudian di kalikan dengan hasil h lalu, akan di buat percabangan yang kondisinya di modulus 2. kemudian nilai dari integrasi dibagi 3 karena ini merupakan simpson 1/3.","title":"Simpson 1/3"},{"location":"Kode-Integrasi-numerik/#simpson_38","text":"def f ( x ): return 1 / ( 1 + x ** 2 ) def simpson38 ( x0 , xn , n ): h = ( xn - x0 ) / n integrasi = f ( x0 ) + f ( xn ) for i in range ( 1 , n ): k = x0 + i * h if i % 2 == 0 : integrasi = integrasi + 2 * f ( k ) else : integrasi = integrasi + 3 * f ( k ) integrasi = integrasi * 3 * h / 8 return integrasi nilai_bawah = float ( input ( \"Batas bawah integrasi : \" )) nilai_atas = float ( input ( \"Batas atas integrasi : \" )) nilai_interval = int ( input ( \"Masukkan jumlah Interval : \" )) nilai = simpson38 ( nilai_bawah , nilai_atas , nilai_interval ) print ( \"Nilai dari integrasi Simpson 3/8 adalah : %0.6f \" % ( nilai ) ) Outputnya: Batas bawah integrasi : 1 Batas atas integrasi : 5 Masukkan jumlah Interval : 2 Nilai dari integrasi Simpson 3/8 adalah : 0.628846 Penjelasan Code : Penjelasannya juga tidak jauh beda dari simpson 1/3 membuat nilai inputan batas bawah dari integrasi tersebut, dan membuat inputan batas atas dari integrasi tersebut juga. lalu juga membuat intervalnya. f adalah fungsi dengan sebuah parameter x. yang akan mengembalikan nilai dari 1/x(pangkat2). x0,xn dan n adalah parameter dalam fungsi simpson13 , x0 yang akan menangkap nilai dari batas bawah, lalu xn dari nilai batas atas dan juga n yang menangkap nilai dari interval. kemudian h adalah variable yang akan menampung hasil kurang dari nilai bawah dan atas yang kemudian di bagi oleh nilai interval. kemudian membuat loopingan yang dibulai dari 1 sampai n. k adalah vaiable dengan nilai x0 yang di jumlahkan dengan inialisasi loopingan yang kemudian di kalikan dengan hasil h lalu, akan di buat percabangan yang kondisinya di modulus 2. kemudian nilai dari integrasi dikali 3 dan dikalikan juga dengan n ilai h lalu dibagi 3 karena ini merupakan simpson 3/8.","title":"Simpson 3/8"},{"location":"Kode-Solusi-Numerik-Diferensial/","text":"Kode Solusi Numerik Diferensial \u00b6 Metode Euler \u00b6 def f ( x , y ): return x + y def euler ( x0 , y0 , xn , n ): h = ( xn - x0 ) / n print ( 'SOLUSI' ) print ( 'x0 \\t y0 \\t slope \\t yn' ) print ( '------------------------------' ) for i in range ( n ): slope = f ( x0 , y0 ) yn = y0 + h * slope print ( ' %.4f \\t %.4f \\t %0.4f \\t %.4f ' % ( x0 , y0 , slope , yn ) ) print ( '------------------------------' ) y0 = yn x0 = x0 + h print ( ' \\n At x= %.4f , y= %.4f ' % ( xn , yn )) print ( 'Masukkan Kondisi Awal : ' ) x0 = float ( input ( 'x0 = ' )) y0 = float ( input ( 'y0 = ' )) print ( 'Masukkan NIlai Perhitungannya : ' ) xn = float ( input ( 'xn = ' )) print ( 'Masukkan Total Langkah : ' ) step = int ( input ( 'Jumlah Langkah = ' )) # Memanggil Fungsi euler ( x0 , y0 , xn , step ) Outputnya : Masukkan Kondisi Awal : x0 = 1 y0 = 1 Masukkan NIlai Perhitungannya : xn = 5 Masukkan Total Langkah : Jumlah Langkah = 3 SOLUSI x0 y0 slope yn ------------------------------ 1 . 0000 1 . 0000 2 . 0000 3 . 6667 ------------------------------ 2 . 3333 3 . 6667 6 . 0000 11 . 6667 ------------------------------ 3 . 6667 11 . 6667 15 . 3333 32 . 1111 ------------------------------ At x=5 . 0000 , y=32 . 1111 Metode Runge - Kutta \u00b6 def f ( x , y ): return x + y def rk4 ( x0 , y0 , xn , n ): h = ( xn - x0 ) / n print ( 'SOLUSI' ) print ( 'x0 \\t y0 \\t yn' ) for i in range ( n ): k1 = h * ( f ( x0 , y0 )) k2 = h * ( f (( x0 + h / 2 ), ( y0 + k1 / 2 ))) k3 = h * ( f (( x0 + h / 2 ), ( y0 + k2 / 2 ))) k4 = h * ( f (( x0 + h ), ( y0 + k3 ))) k = ( k1 + 2 * k2 + 2 * k3 + k4 ) / 6 yn = y0 + k print ( ' %.4f \\t %.4f \\t %.4f ' % ( x0 , y0 , yn ) ) print ( '-------------------------' ) y0 = yn x0 = x0 + h print ( ' \\n At x= %.4f , y= %.4f ' % ( xn , yn )) # Inputs print ( 'Masukkan Kondisi Awal' ) x0 = float ( input ( 'x0 = ' )) y0 = float ( input ( 'y0 = ' )) print ( 'Masukkan nilai Perhitungannya : ' ) xn = float ( input ( 'xn = ' )) print ( 'Masukkan Total Langkah : ' ) step = int ( input ( 'Jumlah Langkah = ' )) # Memanggil fungsi rk4 ( x0 , y0 , xn , step ) Outputnya : Masukkan Kondisi Awal x0 = 1 y0 = 1 Masukkan nilai Perhitungannya : xn = 5 Masukkan Total Langkah : Jumlah Langkah = 3 SOLUSI x0 y0 yn 1.0000 1.0000 7.9136 ------------------------- 2.3333 7.9136 37.4977 ------------------------- 3.6667 37.4977 152.0730 ------------------------- At x=5.0000, y=152.0730","title":"Kode"},{"location":"Kode-Solusi-Numerik-Diferensial/#kode_solusi_numerik_diferensial","text":"","title":"Kode Solusi Numerik Diferensial"},{"location":"Kode-Solusi-Numerik-Diferensial/#metode_euler","text":"def f ( x , y ): return x + y def euler ( x0 , y0 , xn , n ): h = ( xn - x0 ) / n print ( 'SOLUSI' ) print ( 'x0 \\t y0 \\t slope \\t yn' ) print ( '------------------------------' ) for i in range ( n ): slope = f ( x0 , y0 ) yn = y0 + h * slope print ( ' %.4f \\t %.4f \\t %0.4f \\t %.4f ' % ( x0 , y0 , slope , yn ) ) print ( '------------------------------' ) y0 = yn x0 = x0 + h print ( ' \\n At x= %.4f , y= %.4f ' % ( xn , yn )) print ( 'Masukkan Kondisi Awal : ' ) x0 = float ( input ( 'x0 = ' )) y0 = float ( input ( 'y0 = ' )) print ( 'Masukkan NIlai Perhitungannya : ' ) xn = float ( input ( 'xn = ' )) print ( 'Masukkan Total Langkah : ' ) step = int ( input ( 'Jumlah Langkah = ' )) # Memanggil Fungsi euler ( x0 , y0 , xn , step ) Outputnya : Masukkan Kondisi Awal : x0 = 1 y0 = 1 Masukkan NIlai Perhitungannya : xn = 5 Masukkan Total Langkah : Jumlah Langkah = 3 SOLUSI x0 y0 slope yn ------------------------------ 1 . 0000 1 . 0000 2 . 0000 3 . 6667 ------------------------------ 2 . 3333 3 . 6667 6 . 0000 11 . 6667 ------------------------------ 3 . 6667 11 . 6667 15 . 3333 32 . 1111 ------------------------------ At x=5 . 0000 , y=32 . 1111","title":"Metode Euler"},{"location":"Kode-Solusi-Numerik-Diferensial/#metode_runge_-_kutta","text":"def f ( x , y ): return x + y def rk4 ( x0 , y0 , xn , n ): h = ( xn - x0 ) / n print ( 'SOLUSI' ) print ( 'x0 \\t y0 \\t yn' ) for i in range ( n ): k1 = h * ( f ( x0 , y0 )) k2 = h * ( f (( x0 + h / 2 ), ( y0 + k1 / 2 ))) k3 = h * ( f (( x0 + h / 2 ), ( y0 + k2 / 2 ))) k4 = h * ( f (( x0 + h ), ( y0 + k3 ))) k = ( k1 + 2 * k2 + 2 * k3 + k4 ) / 6 yn = y0 + k print ( ' %.4f \\t %.4f \\t %.4f ' % ( x0 , y0 , yn ) ) print ( '-------------------------' ) y0 = yn x0 = x0 + h print ( ' \\n At x= %.4f , y= %.4f ' % ( xn , yn )) # Inputs print ( 'Masukkan Kondisi Awal' ) x0 = float ( input ( 'x0 = ' )) y0 = float ( input ( 'y0 = ' )) print ( 'Masukkan nilai Perhitungannya : ' ) xn = float ( input ( 'xn = ' )) print ( 'Masukkan Total Langkah : ' ) step = int ( input ( 'Jumlah Langkah = ' )) # Memanggil fungsi rk4 ( x0 , y0 , xn , step ) Outputnya : Masukkan Kondisi Awal x0 = 1 y0 = 1 Masukkan nilai Perhitungannya : xn = 5 Masukkan Total Langkah : Jumlah Langkah = 3 SOLUSI x0 y0 yn 1.0000 1.0000 7.9136 ------------------------- 2.3333 7.9136 37.4977 ------------------------- 3.6667 37.4977 152.0730 ------------------------- At x=5.0000, y=152.0730","title":"Metode Runge - Kutta"},{"location":"Kode-Solusi-Numerik/","text":"Kode Pada Solusi Numerik Aljabar \u00b6 Metode Gauss \u00b6 from fractions import Fraction def pprint ( A ): n = len ( A ) for i in range ( 0 , n ): line = \"\" for j in range ( 0 , n + 1 ): line += str ( A [ i ][ j ]) + \" \\t \" if j == n - 1 : line += \"| \" print ( line ) print ( \"\" ) def gauss ( A ): n = len ( A ) for i in range ( 0 , n ): # Menacri Maksimal pada kolom maxE1 = abs ( A [ i ][ i ]) maxRow = i for k in range ( i + 1 , n ): # Melihat setiap baris agar tidak Dimulai dengan 0 if abs ( A [ k ][ i ]) < maxE1 or maxE1 == 0 : maxE1 = abs ( A [ k ][ i ]) maxRow = k # Menukar baris max dengan baris for k in range ( i , n + 1 ): tmp = A [ maxRow ][ k ] A [ maxRow ][ k ] = A [ i ][ k ] A [ i ][ k ] = tmp # Menjadikan 0 disetiap baris for k in range ( i + 1 , n ): c = - A [ k ][ i ] / A [ i ][ i ] for j in range ( i , n + 1 ): if i == j : A [ k ][ j ] = 0 else : A [ k ][ j ] += c * A [ i ][ j ] # Memprint matrik print ( \"Matrix echelon: \\t \" ) pprint ( A ) # Menyelesaikan Persamaan x = [ 0 for i in range ( n )] for i in range ( n - 1 , - 1 , - 1 ): # tidak ada solusi if A [ i ][ i ] == 0 : return [ 0 for i in range ( n )] # Bersolusi else : x [ i ] = A [ i ][ n ] / A [ i ][ i ] for k in range ( i - 1 , - 1 , - 1 ): A [ k ][ n ] -= A [ k ][ i ] * x [ i ] return x print ( 'Masukkan Jumlah Variabel : ' ) n = int ( input ()) # Membuat matrix 0 A = [[ 0 for j in range ( n + 1 )] for i in range ( n )] print ( \"Masukkan setiap baris [contoh(1 2 4)] Lalu enter -> \" ) for i in range ( 0 , n ): line = map ( Fraction , input () . split ( \" \" )) for j , el in enumerate ( line ): A [ i ][ j ] = el print ( \"Membuat Kolom Solusi [Contoh (1 2 4 )] -> \" ) line = input () . split ( \" \" ) lastLine = list ( map ( Fraction , line )) for i in range ( 0 , n ): A [ i ][ n ] = lastLine [ i ] # Cetak Inputan print ( \" \\n Matrix:\" ) pprint ( A ) # Mengkalkulasi Solusi x = gauss ( A ) # Cetak solusi print ( \"Hasil:\" ) # Cek hasil solusi = False for i in range ( n ): if x [ i ] != 0 : solusi = True # Cek solusi if solusi : for i in range ( len ( x )): print ( \"x\" , i + 1 , \" = \" , x [ i ]) # Solusi salah else : print ( \"Tidak Bersolusi\" ) Outputnya : Masukkan Jumlah Variabel : 2 Masukkan setiap baris [ contoh ( 1 2 4 )] Lalu enter -> 1 3 4 2 Membuat Kolom Solusi [ Contoh ( 1 2 4 )] -> 2 2 Matrix : 1 3 | 2 4 2 | 2 Matrix echelon : 1 3 | 2 0 - 10 | - 6 Hasil : x 1 = 1 / 5 x 2 = 3 / 5 Diatas dalah code Python dari Metode Gauss Metode Gauss - Jordan \u00b6 # Mengimport library import numpy as np import sys n = int ( input ( 'Masukkan Jumlah Variabel : ' )) # Membuat array # Menyimpan matrix yang diperbesar a = np . zeros (( n , n + 1 )) # Membuat array dengan ukuran n x = np . zeros ( n ) # Membaca Koefisien print ( 'Masukkan Koefisien matrix: ' ) for i in range ( n ): for j in range ( n + 1 ): a [ i ][ j ] = float ( input ( 'a[' + str ( i ) + '][' + str ( j ) + '] = ' )) # Gauss Jordan for i in range ( n ): if a [ i ][ i ] == 0.0 : sys . exit ( 'Dibagi 0' ) for j in range ( n ): if i != j : ratio = a [ j ][ i ] / a [ i ][ i ] for k in range ( n + 1 ): a [ j ][ k ] = a [ j ][ k ] - ratio * a [ i ][ k ] # Obtaining Solution for i in range ( n ): x [ i ] = a [ i ][ n ] / a [ i ][ i ] # Displaying solution print ( ' \\n Beberapa Solusi' ) for i in range ( n ): print ( 'X %d = %0.2f ' % ( i , x [ i ]), end = ' \\t ' ) Outputnya : Masukkan Jumlah Variabel : 2 Masukkan Koefisien matrix: a[0][0] = 1 a[0][1] = 2 a[0][2] = 4 a[1][0] = 5 a[1][1] = 8 a[1][2] = 2 Beberapa Solusi X0 = -14.00 X1 = 9.00 Diatas adalah code Python Gauss - Jordan Metode Gauss - Seidel \u00b6 # Iterasi Gauss Seidel # Mendefinisikan Persamaan # Diagonal f1 = lambda x , y , z : ( 17 - y + 2 * z ) / 20 f2 = lambda x , y , z : ( - 18 - 3 * x + z ) / 20 f3 = lambda x , y , z : ( 25 - 2 * x + 3 * y ) / 20 # Awal x0 = 0 y0 = 0 z0 = 0 count = 1 # Melihat kesalahan e = float ( input ( 'Kesalahan yang Tertoleransi : ' )) # Iterasi Gauss siedel print ( ' \\n Perhitungan \\t x \\t y \\t z \\n ' ) kondisi = True while kondisi : x1 = f1 ( x0 , y0 , z0 ) y1 = f2 ( x1 , y0 , z0 ) z1 = f3 ( x1 , y1 , z0 ) print ( ' %d \\t %0.4f \\t %0.4f \\t %0.4f \\n ' % ( count , x1 , y1 , z1 )) e1 = abs ( x0 - x1 ); e2 = abs ( y0 - y1 ); e3 = abs ( z0 - z1 ); count += 1 x0 = x1 y0 = y1 z0 = z1 kondisi = e1 > e and e2 > e and e3 > e print ( ' \\n Solusi: x= %0.3f , y= %0.3f and z = %0.3f \\n ' % ( x1 , y1 , z1 )) Outputnya : Kesalahan yang Tertoleransi : 0.5 Perhitungan x y z 1 0.8500 -1.0275 1.0109 2 1.0025 -0.9998 0.9998 Solusi: x=1.002, y=-1.000 and z = 1.000 Diatas adalah metode dari Gauss - Seidel Metode LU dekomposisi \u00b6 # matrix A A = [[ 1 , 2 , 4 ], [ 2 , - 2 , 9 ], [ - 2 , 9 , 2 ]] # vector b b = [ 2 , 4 , 6 ] # Membuat fungsi def show ( matrix ): n = len ( matrix ) for row in range ( n ): for col in range ( n ): print ( ' %.2f ' % matrix [ row ][ col ], end = \" \\t \" ) print ( \"\" ) print ( \"Hasil Dari Matrix :\" ) show ( A ) print ( \"\" ) # Baria A n = len ( A ) # Membuat matrix 0 dari L dan U L = [[ 0 for row in range ( n )] for col in range ( n )] U = [[ 0 for row in range ( n )] for col in range ( n )] for p in range ( n ): # upper matrix for j in range ( p , n ): # summation of L(p,k)*U(k,j) sum = 0 for k in range ( p ): sum = sum + L [ p ][ k ] * U [ k ][ j ] U [ p ][ j ] = A [ p ][ j ] - sum # Matrix Rendah q = p for i in range ( q , n ): if ( i == q ): # Diagonal L L [ i ][ q ] = 1 else : sum = 0 for k in range ( q ): sum = sum + L [ i ][ k ] * U [ k ][ q ] L [ i ][ q ] = ( A [ i ][ q ] - sum ) / U [ q ][ q ] def decomposition ( A ): # get number of rows from A n = len ( A ) # create zeros matrix of L and U L = [[ 0 for row in range ( n )] for col in range ( n )] U = [[ 0 for row in range ( n )] for col in range ( n )] for p in range ( n ): for j in range ( p , n ): sum = 0 for k in range ( p ): sum = sum + L [ p ][ k ] * U [ k ][ j ] U [ p ][ j ] = A [ p ][ j ] - sum q = p for i in range ( q , n ): if ( i == q ): # diagonal of L L [ i ][ q ] = 1 else : sum = 0 for k in range ( q ): sum = sum + L [ i ][ k ] * U [ k ][ q ] L [ i ][ q ] = ( A [ i ][ q ] - sum ) / U [ q ][ q ] return L , U # matrix A A = [[ 3 , 2 , - 1 ], [ 2 , - 2 , 4 ], [ - 1 , 0.5 , - 1 ]] # Kalkulasi Matrix L dan U L , U = decomposition ( A ) # Cetak L dan U print ( \"Matrix L :\" ) show ( L ) print ( \" \\n Matrix U :\" ) show ( U ) Outputnya: Hasil Dari Matrix : 1.00 2.00 4.00 2.00 -2.00 9.00 -2.00 9.00 2.00 Matrix L : 1.00 0.00 0.00 0.67 1.00 0.00 -0.33 -0.35 1.00 Matrix U : 3.00 2.00 -1.00 0.00 -3.33 4.67 0.00 0.00 0.30 Diatas adalah Code dari Dekomposisi L U","title":"Kode"},{"location":"Kode-Solusi-Numerik/#kode_pada_solusi_numerik_aljabar","text":"","title":"Kode Pada Solusi Numerik Aljabar"},{"location":"Kode-Solusi-Numerik/#metode_gauss","text":"from fractions import Fraction def pprint ( A ): n = len ( A ) for i in range ( 0 , n ): line = \"\" for j in range ( 0 , n + 1 ): line += str ( A [ i ][ j ]) + \" \\t \" if j == n - 1 : line += \"| \" print ( line ) print ( \"\" ) def gauss ( A ): n = len ( A ) for i in range ( 0 , n ): # Menacri Maksimal pada kolom maxE1 = abs ( A [ i ][ i ]) maxRow = i for k in range ( i + 1 , n ): # Melihat setiap baris agar tidak Dimulai dengan 0 if abs ( A [ k ][ i ]) < maxE1 or maxE1 == 0 : maxE1 = abs ( A [ k ][ i ]) maxRow = k # Menukar baris max dengan baris for k in range ( i , n + 1 ): tmp = A [ maxRow ][ k ] A [ maxRow ][ k ] = A [ i ][ k ] A [ i ][ k ] = tmp # Menjadikan 0 disetiap baris for k in range ( i + 1 , n ): c = - A [ k ][ i ] / A [ i ][ i ] for j in range ( i , n + 1 ): if i == j : A [ k ][ j ] = 0 else : A [ k ][ j ] += c * A [ i ][ j ] # Memprint matrik print ( \"Matrix echelon: \\t \" ) pprint ( A ) # Menyelesaikan Persamaan x = [ 0 for i in range ( n )] for i in range ( n - 1 , - 1 , - 1 ): # tidak ada solusi if A [ i ][ i ] == 0 : return [ 0 for i in range ( n )] # Bersolusi else : x [ i ] = A [ i ][ n ] / A [ i ][ i ] for k in range ( i - 1 , - 1 , - 1 ): A [ k ][ n ] -= A [ k ][ i ] * x [ i ] return x print ( 'Masukkan Jumlah Variabel : ' ) n = int ( input ()) # Membuat matrix 0 A = [[ 0 for j in range ( n + 1 )] for i in range ( n )] print ( \"Masukkan setiap baris [contoh(1 2 4)] Lalu enter -> \" ) for i in range ( 0 , n ): line = map ( Fraction , input () . split ( \" \" )) for j , el in enumerate ( line ): A [ i ][ j ] = el print ( \"Membuat Kolom Solusi [Contoh (1 2 4 )] -> \" ) line = input () . split ( \" \" ) lastLine = list ( map ( Fraction , line )) for i in range ( 0 , n ): A [ i ][ n ] = lastLine [ i ] # Cetak Inputan print ( \" \\n Matrix:\" ) pprint ( A ) # Mengkalkulasi Solusi x = gauss ( A ) # Cetak solusi print ( \"Hasil:\" ) # Cek hasil solusi = False for i in range ( n ): if x [ i ] != 0 : solusi = True # Cek solusi if solusi : for i in range ( len ( x )): print ( \"x\" , i + 1 , \" = \" , x [ i ]) # Solusi salah else : print ( \"Tidak Bersolusi\" ) Outputnya : Masukkan Jumlah Variabel : 2 Masukkan setiap baris [ contoh ( 1 2 4 )] Lalu enter -> 1 3 4 2 Membuat Kolom Solusi [ Contoh ( 1 2 4 )] -> 2 2 Matrix : 1 3 | 2 4 2 | 2 Matrix echelon : 1 3 | 2 0 - 10 | - 6 Hasil : x 1 = 1 / 5 x 2 = 3 / 5 Diatas dalah code Python dari Metode Gauss","title":"Metode Gauss"},{"location":"Kode-Solusi-Numerik/#metode_gauss_-_jordan","text":"# Mengimport library import numpy as np import sys n = int ( input ( 'Masukkan Jumlah Variabel : ' )) # Membuat array # Menyimpan matrix yang diperbesar a = np . zeros (( n , n + 1 )) # Membuat array dengan ukuran n x = np . zeros ( n ) # Membaca Koefisien print ( 'Masukkan Koefisien matrix: ' ) for i in range ( n ): for j in range ( n + 1 ): a [ i ][ j ] = float ( input ( 'a[' + str ( i ) + '][' + str ( j ) + '] = ' )) # Gauss Jordan for i in range ( n ): if a [ i ][ i ] == 0.0 : sys . exit ( 'Dibagi 0' ) for j in range ( n ): if i != j : ratio = a [ j ][ i ] / a [ i ][ i ] for k in range ( n + 1 ): a [ j ][ k ] = a [ j ][ k ] - ratio * a [ i ][ k ] # Obtaining Solution for i in range ( n ): x [ i ] = a [ i ][ n ] / a [ i ][ i ] # Displaying solution print ( ' \\n Beberapa Solusi' ) for i in range ( n ): print ( 'X %d = %0.2f ' % ( i , x [ i ]), end = ' \\t ' ) Outputnya : Masukkan Jumlah Variabel : 2 Masukkan Koefisien matrix: a[0][0] = 1 a[0][1] = 2 a[0][2] = 4 a[1][0] = 5 a[1][1] = 8 a[1][2] = 2 Beberapa Solusi X0 = -14.00 X1 = 9.00 Diatas adalah code Python Gauss - Jordan","title":"Metode Gauss - Jordan"},{"location":"Kode-Solusi-Numerik/#metode_gauss_-_seidel","text":"# Iterasi Gauss Seidel # Mendefinisikan Persamaan # Diagonal f1 = lambda x , y , z : ( 17 - y + 2 * z ) / 20 f2 = lambda x , y , z : ( - 18 - 3 * x + z ) / 20 f3 = lambda x , y , z : ( 25 - 2 * x + 3 * y ) / 20 # Awal x0 = 0 y0 = 0 z0 = 0 count = 1 # Melihat kesalahan e = float ( input ( 'Kesalahan yang Tertoleransi : ' )) # Iterasi Gauss siedel print ( ' \\n Perhitungan \\t x \\t y \\t z \\n ' ) kondisi = True while kondisi : x1 = f1 ( x0 , y0 , z0 ) y1 = f2 ( x1 , y0 , z0 ) z1 = f3 ( x1 , y1 , z0 ) print ( ' %d \\t %0.4f \\t %0.4f \\t %0.4f \\n ' % ( count , x1 , y1 , z1 )) e1 = abs ( x0 - x1 ); e2 = abs ( y0 - y1 ); e3 = abs ( z0 - z1 ); count += 1 x0 = x1 y0 = y1 z0 = z1 kondisi = e1 > e and e2 > e and e3 > e print ( ' \\n Solusi: x= %0.3f , y= %0.3f and z = %0.3f \\n ' % ( x1 , y1 , z1 )) Outputnya : Kesalahan yang Tertoleransi : 0.5 Perhitungan x y z 1 0.8500 -1.0275 1.0109 2 1.0025 -0.9998 0.9998 Solusi: x=1.002, y=-1.000 and z = 1.000 Diatas adalah metode dari Gauss - Seidel","title":"Metode Gauss - Seidel"},{"location":"Kode-Solusi-Numerik/#metode_lu_dekomposisi","text":"# matrix A A = [[ 1 , 2 , 4 ], [ 2 , - 2 , 9 ], [ - 2 , 9 , 2 ]] # vector b b = [ 2 , 4 , 6 ] # Membuat fungsi def show ( matrix ): n = len ( matrix ) for row in range ( n ): for col in range ( n ): print ( ' %.2f ' % matrix [ row ][ col ], end = \" \\t \" ) print ( \"\" ) print ( \"Hasil Dari Matrix :\" ) show ( A ) print ( \"\" ) # Baria A n = len ( A ) # Membuat matrix 0 dari L dan U L = [[ 0 for row in range ( n )] for col in range ( n )] U = [[ 0 for row in range ( n )] for col in range ( n )] for p in range ( n ): # upper matrix for j in range ( p , n ): # summation of L(p,k)*U(k,j) sum = 0 for k in range ( p ): sum = sum + L [ p ][ k ] * U [ k ][ j ] U [ p ][ j ] = A [ p ][ j ] - sum # Matrix Rendah q = p for i in range ( q , n ): if ( i == q ): # Diagonal L L [ i ][ q ] = 1 else : sum = 0 for k in range ( q ): sum = sum + L [ i ][ k ] * U [ k ][ q ] L [ i ][ q ] = ( A [ i ][ q ] - sum ) / U [ q ][ q ] def decomposition ( A ): # get number of rows from A n = len ( A ) # create zeros matrix of L and U L = [[ 0 for row in range ( n )] for col in range ( n )] U = [[ 0 for row in range ( n )] for col in range ( n )] for p in range ( n ): for j in range ( p , n ): sum = 0 for k in range ( p ): sum = sum + L [ p ][ k ] * U [ k ][ j ] U [ p ][ j ] = A [ p ][ j ] - sum q = p for i in range ( q , n ): if ( i == q ): # diagonal of L L [ i ][ q ] = 1 else : sum = 0 for k in range ( q ): sum = sum + L [ i ][ k ] * U [ k ][ q ] L [ i ][ q ] = ( A [ i ][ q ] - sum ) / U [ q ][ q ] return L , U # matrix A A = [[ 3 , 2 , - 1 ], [ 2 , - 2 , 4 ], [ - 1 , 0.5 , - 1 ]] # Kalkulasi Matrix L dan U L , U = decomposition ( A ) # Cetak L dan U print ( \"Matrix L :\" ) show ( L ) print ( \" \\n Matrix U :\" ) show ( U ) Outputnya: Hasil Dari Matrix : 1.00 2.00 4.00 2.00 -2.00 9.00 -2.00 9.00 2.00 Matrix L : 1.00 0.00 0.00 0.67 1.00 0.00 -0.33 -0.35 1.00 Matrix U : 3.00 2.00 -1.00 0.00 -3.33 4.67 0.00 0.00 0.30 Diatas adalah Code dari Dekomposisi L U","title":"Metode LU dekomposisi"},{"location":"Materi-Solusi-Numerik-Diferensial/","text":"Solusi Numerik Diferensial \u00b6 \u200b Persamaan DIferensial Biasa adalah persamaan yang hanya memiliki satu peubah bebas. Biasanya disimbolkan dengan x. berikut contoh dari persamaan diferensial biasa $$ \\begin{aligned} \\dfrac{dy}{dx}=x+y \\space \\space (i) \\ y' = x^{2}+y^{2} \\space \\space (ii) \\ 2\\dfrac{dy}{dx}+x^{2}y-y=0 \\space \\space (iii) \\ y'' +y'cos\\space x-3y=sin\\space2x \\space \\space (iv) \\ 2y'''-23y'=1-y'' \\space \\space (v) \\end{aligned} $$ A. Metode Euler \u00b6 \u200b Metode ini adalah sebuah metode yang sangat sederhana yang dihasilkan dari diturunkannya deret taylor. $$ y_{i+1} = y_{i}+f(x_{i},y_{i})h $$ Note : i adalah tahapan dari iterasi B. Metode Heun \u00b6 \u200b Metode ini adalah peningkatan dari metode euler. pada metode ini digunakan 2 buah persamaan. Persamaan yang pertama adalah persamaan prediktor dan yang kedua adalah persamaan korektor dan yang dikoreksi adalah integrasi awal. Untuk meningkatkan akurasi pada integrasi lakukan koreksi secara berulang menggunakan rumus korektor. Rumus Prediktor \\[ y^{0}_{i+1}=y_{i}+f(x_{i},y_{i})h \\] Rumus Korektor \\[ y_{i+1}=y_{i}+\\dfrac{f(x_{i},y_{i})+f(x_{i+1},y^{0}_{i+1})}{2}h \\] C. Metode Titik Tengah \u00b6 \u200b Metode ini menggunakan setengah step size untuk metode Euler ketika melakukan sebuah estimasi pada integral. Pada metode ini ada dua tahapan perhitungan. Yaitu nilai estimasi integral yang dihitung di setengah step size $$ y_{i+0,5} = y_{i}+f(x_{i},y_{i})\\dfrac{h}{2} $$ dan menghitung nilai integral dengan hasil hitung setengah step size yang sebelumnya. $$ y_{i+0,5}=y_{i}+f(x_{i+0,5},y_{i+0,5})h $$ D. Metode Runge-Kutta Orde 4 \u00b6 \u200b ini adalah sebuah metode yang sangat populer dalam sebuah penyelesaian persamaan diferensial. Metode ini dapat menghasilkan akurasi deret taylor tanpa diferensiasi orde yang lebih tinggi. rumus metode ini $$ y_{i+1}=y_{i}+\\dfrac{1}{0}(k_{1}+2k_{2}+2k_{3}+k_{4})h $$ dimana : $$ \\begin{aligned} k_{1} = f(x_{i},y_{i}) \\ k_{2}=f\\left(x_{1}+\\dfrac{1}{2}h,y_{i}+\\dfrac{1}{2}k_{1}h \\right) \\ k_{3}=f\\left(x_{1}+\\dfrac{1}{2}h,y_{i}+\\dfrac{1}{2}k_{2}h \\right) \\ k_{4}=f(x_{i}+h,y_{i}+K_{3}h) \\end{aligned} $$","title":"Materi"},{"location":"Materi-Solusi-Numerik-Diferensial/#solusi_numerik_diferensial","text":"\u200b Persamaan DIferensial Biasa adalah persamaan yang hanya memiliki satu peubah bebas. Biasanya disimbolkan dengan x. berikut contoh dari persamaan diferensial biasa $$ \\begin{aligned} \\dfrac{dy}{dx}=x+y \\space \\space (i) \\ y' = x^{2}+y^{2} \\space \\space (ii) \\ 2\\dfrac{dy}{dx}+x^{2}y-y=0 \\space \\space (iii) \\ y'' +y'cos\\space x-3y=sin\\space2x \\space \\space (iv) \\ 2y'''-23y'=1-y'' \\space \\space (v) \\end{aligned} $$","title":"Solusi Numerik Diferensial"},{"location":"Materi-Solusi-Numerik-Diferensial/#a_metode_euler","text":"\u200b Metode ini adalah sebuah metode yang sangat sederhana yang dihasilkan dari diturunkannya deret taylor. $$ y_{i+1} = y_{i}+f(x_{i},y_{i})h $$ Note : i adalah tahapan dari iterasi","title":"A. Metode Euler"},{"location":"Materi-Solusi-Numerik-Diferensial/#b_metode_heun","text":"\u200b Metode ini adalah peningkatan dari metode euler. pada metode ini digunakan 2 buah persamaan. Persamaan yang pertama adalah persamaan prediktor dan yang kedua adalah persamaan korektor dan yang dikoreksi adalah integrasi awal. Untuk meningkatkan akurasi pada integrasi lakukan koreksi secara berulang menggunakan rumus korektor. Rumus Prediktor \\[ y^{0}_{i+1}=y_{i}+f(x_{i},y_{i})h \\] Rumus Korektor \\[ y_{i+1}=y_{i}+\\dfrac{f(x_{i},y_{i})+f(x_{i+1},y^{0}_{i+1})}{2}h \\]","title":"B. Metode Heun"},{"location":"Materi-Solusi-Numerik-Diferensial/#c_metode_titik_tengah","text":"\u200b Metode ini menggunakan setengah step size untuk metode Euler ketika melakukan sebuah estimasi pada integral. Pada metode ini ada dua tahapan perhitungan. Yaitu nilai estimasi integral yang dihitung di setengah step size $$ y_{i+0,5} = y_{i}+f(x_{i},y_{i})\\dfrac{h}{2} $$ dan menghitung nilai integral dengan hasil hitung setengah step size yang sebelumnya. $$ y_{i+0,5}=y_{i}+f(x_{i+0,5},y_{i+0,5})h $$","title":"C. Metode Titik Tengah"},{"location":"Materi-Solusi-Numerik-Diferensial/#d_metode_runge-kutta_orde_4","text":"\u200b ini adalah sebuah metode yang sangat populer dalam sebuah penyelesaian persamaan diferensial. Metode ini dapat menghasilkan akurasi deret taylor tanpa diferensiasi orde yang lebih tinggi. rumus metode ini $$ y_{i+1}=y_{i}+\\dfrac{1}{0}(k_{1}+2k_{2}+2k_{3}+k_{4})h $$ dimana : $$ \\begin{aligned} k_{1} = f(x_{i},y_{i}) \\ k_{2}=f\\left(x_{1}+\\dfrac{1}{2}h,y_{i}+\\dfrac{1}{2}k_{1}h \\right) \\ k_{3}=f\\left(x_{1}+\\dfrac{1}{2}h,y_{i}+\\dfrac{1}{2}k_{2}h \\right) \\ k_{4}=f(x_{i}+h,y_{i}+K_{3}h) \\end{aligned} $$","title":"D. Metode Runge-Kutta Orde 4"},{"location":"algoritma-simpson/","text":"Algoritma Metode Simpson \u00b6 Mendefinisikan y = f(x) Menentukan batas bawah dan batas atasnya (a,b) Menentukan Jumlah pembaginya (n) Hitung h dengan rumus berikut : $$ h = \\dfrac{(b-a)}{n} $$ X adalah x = 1, 2, 3, ... , n-1 Hitung L dengan rumus berikut : $$ L= \\dfrac{h}{2}[f_{0} + 4 \\Sigma_{i ganjil}f_{i}+2\\Sigma_{i genap}F_{i}+f_{n}] $$","title":"Algoritma Simpson"},{"location":"algoritma-simpson/#algoritma_metode_simpson","text":"Mendefinisikan y = f(x) Menentukan batas bawah dan batas atasnya (a,b) Menentukan Jumlah pembaginya (n) Hitung h dengan rumus berikut : $$ h = \\dfrac{(b-a)}{n} $$ X adalah x = 1, 2, 3, ... , n-1 Hitung L dengan rumus berikut : $$ L= \\dfrac{h}{2}[f_{0} + 4 \\Sigma_{i ganjil}f_{i}+2\\Sigma_{i genap}F_{i}+f_{n}] $$","title":"Algoritma Metode Simpson"},{"location":"license/","text":"License \u00b6 MIT License The graduate cap icon made by Freepik from www.flaticon.com is licensed by CC 3.0 BY Support Author \u00b6 Amazon wish list","title":"License"},{"location":"license/#license","text":"MIT License The graduate cap icon made by Freepik from www.flaticon.com is licensed by CC 3.0 BY","title":"License"},{"location":"license/#support_author","text":"Amazon wish list","title":"Support Author"},{"location":"materi-Solusi-Numerik/","text":"Solusi Numerik Aljabar Linear \u00b6 A. Eliminasi Gauss \u00b6 \u200b Sebuah algoritma yang tujuannya digunakan untuk menyelesaikan sistem persamaan linear. Metode eliminasi gauss mendapatkan nama sesuai dengan matematikawan Carl Friedrich Gauss (1777-1855), meskipun metode Gauss sendiri sudah terkenal dikalangan matematikawan Tionghoa dari tahun 199 M. Untuk mengoperasikan metode ini, ada tiga jenis operasinya : Mengganti urutan pada dua baris Mengalikan baris baris dengan angka yang bukan 0 Menambahkan suatu baris dengan baris lainnya Cara diatas adalah cara untuk merubah matriks menjadi matriks segitiga atas. Beberapa persamaan linear aljabar pada umumnya \\[ \\begin{aligned} a_{11}x_{1} + a_{12}x_{2}+...+a_{1n}x_{n}=b_{1} \\\\ a_{21}x_{1}+a_{22}x_{2}+...+a_{2n}x_{n}=b2 \\\\ a_{n1}x_{1}+a_{n2}x_{2}+...+a_{nn}x_{n}=b_{n} \\end{aligned} \\] Eliminasi gauss dilakukan melalui beberapa langkah utama: Menghapus kedepan dari yang tidak di ketahui Pertama adalah mengurangi persamaan dan membetuk triangular atas Eliminasi Varialel pertama (x1) untuk baris kedua sampai baris ke n dengan cara mengurangi koefisien dari variabel yang ada pada semua baris $$ a_{11}x_{1}+a_{12}x_{2}+...+a_{1n}x_{n}=b_{1} $$ $$ \\begin{aligned} 0_{x_{1}}+(a_{22}-\\dfrac{a_{21}}{a_{11}}a_{12})x_{2}+...+(a_{2n}-\\dfrac{a_{21}}{a_{11}}a_{1n})x_{n}=b_{2}-\\dfrac{a_{21}}{a_{11}}b_{1} \\ 0_{x_{1}}+(a_{n2}-\\dfrac{a_{n1}}{a_{11}}a_{12})x_{2}+...+(a_{nn}-\\dfrac{a_{n1}}{a_{11}}a_{1n})x_{n}=b_{n}-\\dfrac{a_{n1}}{a_{11}}b_{1} \\end{aligned} $$ Atau dinyatakan sebagai : $$ a_{11}x_{1}+a_{12}x_{2}+...+a_{1n}x_{n}=b_{1} $$ $$ 0_{x1} + a_{12}x_{2}+...+a_{2n}x_{n}=b^{^{I}}_{1} $$ $$ untuk \\space a \\space dan \\space b \\space aksen $$ $$ 0_{x_{1}}+a_{22}x_{2}+...+a_{2n}x_{n}=b_{2} $$ $$ 0_{x_{1}}+a_{n2}x_{2}+...+a_{nn}x_{n}=b_{n} $$ Dari hasil diatas, eliminasi untuk variabel kedua dari garis ketiga hingga terakhir dengan cara mengurangi koefisiennya di semua variabel pada baris sehingga hasilnya adalah 0 pada di koefisien (X2) digaris ketiga sampai akhir, maka akan didapatkan hasil seperti berikut $$ a_{11}x_{1}+a_{12}x_{2}+...+a_{1n}x_{n}=b_{1} $$ $$ 0_{x_{1}}+(a_{22}-\\dfrac{a_{21}}{a_{11}}a_{12})x_{2}+...+(a_{2n}-\\dfrac{a_{21}}{a_{11}}a_{1n})x_{n}=b_{2}-\\dfrac{a_{21}}{a_{11}}b_{1} $$ $$ untuk \\space a \\space dan \\space b \\space aksen $$ $$ 0_{x_{1}}+0_{x_{2}}+(a_{33}-\\dfrac{a_{32}}{a_{22}}a_{23})x_{3}+...+(a_{3n}-\\dfrac{a_{32}}{a_{22}}a_{2n})x_{n}=b_{3}-\\dfrac{a_{32}}{a_{22}}b_{2} $$ $$ 0_{x_{1}}+0_{x_{2}}+(a_{n3}-\\dfrac{a_{n2}}{a_{22}}a_{2n})x_{3}+...+(a_{nn}-\\dfrac{a_{n2}}{a_{22}}a_{2n})x_{n}=b_{n}-\\dfrac{a_{n2}}{a_{22}}b_{2} $$ atau dinyatakan sebagai $$ a_{11}x_{1}+a_{12}x_{2}+...+a_{1n}x_{n}=b_{1} $$ $$ untuk \\space a \\space dan \\space b \\space aksen $$ $$ 0_{x_{1}}+a_{22}x_{2}+...+a_{2n}x_{n}=b_{2} $$ $$ untuk \\space a \\space dan \\space b \\space aksen \\space 2 $$ $$ 0_{x_{1}}+0_{x_{2}}+...+a_{nn}x_{n}=b_{n} $$ Lakukan berulang kali hingga menyisakan satu variabel dan satu konstanta $$ a_{11}x_{1}+a_{12}x_{2}+...+a_{1n}x_{n}=b_{1} $$ $$ untuk \\space a \\space dan \\space b \\space aksen $$ $$ a_{22}x_{2}+...+a_{2n}x_{n}=b_{2} $$ $$ untuk \\space a \\space dan \\space b \\space aksen \\space 3 $$ $$ a_{33}x_{3}+...+a_{3n}x_{n}=b_{3} $$ dan akhirnya = \\(a^{(n-1)}_{nn}x_{n} = b^{(n-1)}_{n}\\) Substitusi Mundur Ketika sudah didapatkan persamaan yang akhir, lalu mencari nilai variable terakhir, caranya membagi konstanta dengan koefisien variabel itu sendiri \\(x_{n}=\\dfrac{b^{(n-1)}_{n}}{a^{(n-1)}_{nn}}\\) lalu substitusikan hasil (Xn) ke persamaan yang ada di atasnya Begini Alurnya : $$ \\begin{bmatrix} a_{11} & a_{12} & a_{13} \\vdots b_{1} \\ a_{21} & a_{22} & a_{23} \\vdots b_{2} \\ a_{31} & a_{32} & a_{33} \\vdots b_{3} \\end{bmatrix} \\rightarrow \\begin{aligned} R_{2}-\\dfrac{a_{21}}{a_{11}}R_{1} \\ R_{3}-\\dfrac{a_{21}}{a_{11}}R_{1} \\end{aligned} \\rightarrow $$ $$ \\rightarrow \\begin{bmatrix} a_{11} & a_{12} & a_{13} \\vdots b_{1} \\ 0 & a_{22} & a_{23} \\vdots b_{2} \\ 0 & a_{32} & a_{33} \\vdots b_{3} \\end{bmatrix} \\rightarrow \\begin{aligned}R_{3}-\\dfrac{a_{32}}{a_{22}}R_{1} \\end{aligned} \\rightarrow $$ $$ \\rightarrow \\begin{bmatrix} a_{11} & a_{12} & a_{13} \\vdots b_{1} \\ 0 & a_{22} & a_{23} \\vdots b_{2} \\ 0 & a_{32} & a_{33} \\vdots b_{3} \\end{bmatrix} $$ Dilakukan dari bawah $$ untuk \\space a \\space dan \\space b \\space aksen \\space 2 $$ $$ a_{33} \\vdots b_{3} \\rightarrow x_{3}=\\dfrac{b_{3}}{a_{33}} $$ $$ untuk \\space a \\space dan \\space b \\space aksen $$ $$ a_{22}a_{23} \\vdots b_{2} \\rightarrow a_{22}x_{2}+a_{23}x_{3}=b_{2} $$ $$ untuk \\space a \\space dan \\space b \\space aksen $$ $$ Kedua \\space diatas \\rightarrow x_{2}= \\dfrac{b_{2}-a_{23}x_{3}}{a_{22}} $$ $$ a_{11} a_{12} a_{13} \\vdots b_{1} \\rightarrow a_{11}x_{1}+a_{12}x_{2}+a_{13}x_{3}=b_{1} $$ $$ kedua \\space diatas \\rightarrow x_{1}= \\dfrac{b_{1}-a_{13}x_{3}-a_{12}x_{2}}{a_{11}} $$ B. Eliminasi Gauss-Jordan \u00b6 \u200b Metode eliminasi Gauss-Jordan adalah metode modifikasi dari Gauss, dimetode ini dilakukan normalisasi oleh pivot koefisiennya, maka dari itu akan menghasilkan matrix identitas. $$ \\begin{bmatrix} a_{11} & a_{12} & a_{13} \\vdots b_{1} \\ a_{21} & a_{22} & a_{23} \\vdots b_{2} \\ a_{31} & a_{32} & a_{33} \\vdots b_{3} \\end{bmatrix} \\rightarrow \\dfrac{R_{1}}{a_{11}} \\rightarrow $$ \\[ \\rightarrow \\begin{bmatrix} 1 & a'_{12} & a'_{13} \\vdots b'_{1} \\\\ a_{21} & a_{22} & a_{23} \\vdots b_{2} \\\\ a_{31} & a_{32} & a_{33} \\vdots b_{3} \\end{bmatrix} \\rightarrow \\begin{aligned} R_{2}-\\dfrac{a_{21}}{1}R_{1} \\\\ R_{3}- \\dfrac{a_{21}}{1}R_{1} \\end{aligned} \\rightarrow \\] \\[ \\rightarrow \\begin{bmatrix} 1 & a'_{12} & a'_{13} \\vdots b'_{1} \\\\ 0 & a'_{22} & a'_{23} \\vdots b'_{2} \\\\ 0 & a'_{32} & a'_{33} \\vdots b'_{3} \\end{bmatrix} \\rightarrow \\dfrac{R_{2}}{a'_{22}} \\rightarrow \\] \\[ \\rightarrow \\begin{bmatrix} 1 & a'_{12} & a'_{13} \\vdots b'_{1} \\\\ 0 & 1 & a''_{23} \\vdots b''_{2} \\\\ 0 & a'_{32} & a'_{33} \\vdots b'_{3} \\end{bmatrix} \\rightarrow \\begin{aligned} R_{1}-\\dfrac{a'_{12}}{1}R_{2} \\\\ R_{3}-\\dfrac{a'_{32}}{1}R_{2} \\end{aligned} \\rightarrow \\] \\[ \\rightarrow \\begin{bmatrix} 1 & 0 & a''_{13} \\vdots b''_{1} \\\\ 0 & 1 & a''_{23} \\vdots b''_{2} \\\\ 0 & 0 & a''_{33} \\vdots b''_{3} \\end{bmatrix} \\rightarrow \\dfrac{R_{3}}{a''_{33}} \\rightarrow \\] \\[ \\rightarrow \\begin{bmatrix} 1 & 0 & a''_{13} \\vdots b''_{1} \\\\ 0 & 1 & a''_{23} \\vdots b''_{2} \\\\ 0 & 0 & 1 \\vdots b''_{3} \\end{bmatrix} \\rightarrow \\begin{aligned} R_{2}-\\dfrac{a''_{23}}{1}R_{3} \\\\ R_{1}-\\dfrac{a''_{13}}{1}R_{3} \\end{aligned} \\rightarrow \\] \\[ \\rightarrow \\begin{bmatrix} 1 & 0 & 0 \\vdots b''_{1} \\\\ 0 & 1 & 0 \\vdots b''_{2} \\\\ 0 & 0 & 1 \\vdots b''_{3} \\end{bmatrix} \\rightarrow \\begin{aligned} x_{1}=b'''_{1} \\\\ x_{2}=b'''_{2} \\\\ x_{3}=b'''_{3} \\end{aligned} \\] C. Gauss - Siedel \u00b6 \u200b metode ini merupakan iterasi yang menggunakan asumsi matrix [A] [X] = [B] yang mempunyai batasan berupa matrix 3x3, pada diagonal elemetnya tidak sama dengan 0, pada persamaannya mempunyai sifat konvergen. \\[ \\begin{aligned} a_{11}x_{1} + a_{12}x_{2}+a_{13}x_{3}=b_{1} \\\\ a_{21}x_{1} + a_{22}x_{2}+a_{23}x_{3}=b_{2} \\\\ a_{31}x_{1} + a_{32}x_{2}+a_{33}x_{3}=b_{3} \\end{aligned} \\rightarrow \\begin{aligned} x_{1}=\\dfrac{b_{1}-a_{13}x_{3}-a_{12}x_{2}}{a_{11}} \\\\ x_{2}=\\dfrac{b_{2}-a_{21}x_{1}-a_{23}x_{3}}{a_{22}} \\\\ x_{3}=\\dfrac{b_{3}-a_{31}x_{1}-a_{32}x_{2}}{a_{33}} \\end{aligned} \\] Iterasi Pertama : Mencari X1 dengan X2 = 0 dan X3 = 0 \\[ X_{1}=\\dfrac{b_{1}-a_{13}x_{3}-a_{12}x_{2}}{a_{11}} \\rightarrow x_{1}=\\dfrac {b_{1}}{a_{11}} \\] Mencari X2 dengan X3 = 0 dan X1 (baru) \\[ X_{2}=\\dfrac{b_{2}-a_{21}x_{1}-a_{23}x_{3}}{a_{22}} \\rightarrow x_{2}=\\dfrac {b_{2}-a_{21}x_{1}}{a_{22}} \\] mencari X3 dengan X2(baru) dan X1 (baru) \\[ X_{3}=\\dfrac{b_{3}-a_{31}x_{1}-a_{32}x_{2}}{a_{33}} \\] Iterasi Kedua: Mencari X1 dengan X3 (baru) dan X2 (baru) \\[ X_{1}=\\dfrac{b_{1}-a_{13}x_{3}-a_{12}x_{2}}{a_{11}} \\] Menacari X2 dengan X1 (baru) dan X3 (baru) \\[ X_{2}=\\dfrac{b_{2}-a_{21}x_{1}-a_{23}x_{3}}{a_{22}} \\] Mencari X3 dengan X2 (baru) dan X1 (baru) \\[ X_{3}=\\dfrac{b_{3}-a_{31}x_{1}-a_{32}x_{2}}{a_{33}} \\] D. Dekomposisi LU \u00b6 \u200b Merupakan metode dengan matrix yang ada di kiri [A] akan dimanipulasi sehingga menjadi matrix lower ([L]) dan matrix upper ([U]). metode ini adalah kombinasi dari Gauss dan Gauss-Jordan dengan","title":"Materi"},{"location":"materi-Solusi-Numerik/#solusi_numerik_aljabar_linear","text":"","title":"Solusi Numerik Aljabar Linear"},{"location":"materi-Solusi-Numerik/#a_eliminasi_gauss","text":"\u200b Sebuah algoritma yang tujuannya digunakan untuk menyelesaikan sistem persamaan linear. Metode eliminasi gauss mendapatkan nama sesuai dengan matematikawan Carl Friedrich Gauss (1777-1855), meskipun metode Gauss sendiri sudah terkenal dikalangan matematikawan Tionghoa dari tahun 199 M. Untuk mengoperasikan metode ini, ada tiga jenis operasinya : Mengganti urutan pada dua baris Mengalikan baris baris dengan angka yang bukan 0 Menambahkan suatu baris dengan baris lainnya Cara diatas adalah cara untuk merubah matriks menjadi matriks segitiga atas. Beberapa persamaan linear aljabar pada umumnya \\[ \\begin{aligned} a_{11}x_{1} + a_{12}x_{2}+...+a_{1n}x_{n}=b_{1} \\\\ a_{21}x_{1}+a_{22}x_{2}+...+a_{2n}x_{n}=b2 \\\\ a_{n1}x_{1}+a_{n2}x_{2}+...+a_{nn}x_{n}=b_{n} \\end{aligned} \\] Eliminasi gauss dilakukan melalui beberapa langkah utama: Menghapus kedepan dari yang tidak di ketahui Pertama adalah mengurangi persamaan dan membetuk triangular atas Eliminasi Varialel pertama (x1) untuk baris kedua sampai baris ke n dengan cara mengurangi koefisien dari variabel yang ada pada semua baris $$ a_{11}x_{1}+a_{12}x_{2}+...+a_{1n}x_{n}=b_{1} $$ $$ \\begin{aligned} 0_{x_{1}}+(a_{22}-\\dfrac{a_{21}}{a_{11}}a_{12})x_{2}+...+(a_{2n}-\\dfrac{a_{21}}{a_{11}}a_{1n})x_{n}=b_{2}-\\dfrac{a_{21}}{a_{11}}b_{1} \\ 0_{x_{1}}+(a_{n2}-\\dfrac{a_{n1}}{a_{11}}a_{12})x_{2}+...+(a_{nn}-\\dfrac{a_{n1}}{a_{11}}a_{1n})x_{n}=b_{n}-\\dfrac{a_{n1}}{a_{11}}b_{1} \\end{aligned} $$ Atau dinyatakan sebagai : $$ a_{11}x_{1}+a_{12}x_{2}+...+a_{1n}x_{n}=b_{1} $$ $$ 0_{x1} + a_{12}x_{2}+...+a_{2n}x_{n}=b^{^{I}}_{1} $$ $$ untuk \\space a \\space dan \\space b \\space aksen $$ $$ 0_{x_{1}}+a_{22}x_{2}+...+a_{2n}x_{n}=b_{2} $$ $$ 0_{x_{1}}+a_{n2}x_{2}+...+a_{nn}x_{n}=b_{n} $$ Dari hasil diatas, eliminasi untuk variabel kedua dari garis ketiga hingga terakhir dengan cara mengurangi koefisiennya di semua variabel pada baris sehingga hasilnya adalah 0 pada di koefisien (X2) digaris ketiga sampai akhir, maka akan didapatkan hasil seperti berikut $$ a_{11}x_{1}+a_{12}x_{2}+...+a_{1n}x_{n}=b_{1} $$ $$ 0_{x_{1}}+(a_{22}-\\dfrac{a_{21}}{a_{11}}a_{12})x_{2}+...+(a_{2n}-\\dfrac{a_{21}}{a_{11}}a_{1n})x_{n}=b_{2}-\\dfrac{a_{21}}{a_{11}}b_{1} $$ $$ untuk \\space a \\space dan \\space b \\space aksen $$ $$ 0_{x_{1}}+0_{x_{2}}+(a_{33}-\\dfrac{a_{32}}{a_{22}}a_{23})x_{3}+...+(a_{3n}-\\dfrac{a_{32}}{a_{22}}a_{2n})x_{n}=b_{3}-\\dfrac{a_{32}}{a_{22}}b_{2} $$ $$ 0_{x_{1}}+0_{x_{2}}+(a_{n3}-\\dfrac{a_{n2}}{a_{22}}a_{2n})x_{3}+...+(a_{nn}-\\dfrac{a_{n2}}{a_{22}}a_{2n})x_{n}=b_{n}-\\dfrac{a_{n2}}{a_{22}}b_{2} $$ atau dinyatakan sebagai $$ a_{11}x_{1}+a_{12}x_{2}+...+a_{1n}x_{n}=b_{1} $$ $$ untuk \\space a \\space dan \\space b \\space aksen $$ $$ 0_{x_{1}}+a_{22}x_{2}+...+a_{2n}x_{n}=b_{2} $$ $$ untuk \\space a \\space dan \\space b \\space aksen \\space 2 $$ $$ 0_{x_{1}}+0_{x_{2}}+...+a_{nn}x_{n}=b_{n} $$ Lakukan berulang kali hingga menyisakan satu variabel dan satu konstanta $$ a_{11}x_{1}+a_{12}x_{2}+...+a_{1n}x_{n}=b_{1} $$ $$ untuk \\space a \\space dan \\space b \\space aksen $$ $$ a_{22}x_{2}+...+a_{2n}x_{n}=b_{2} $$ $$ untuk \\space a \\space dan \\space b \\space aksen \\space 3 $$ $$ a_{33}x_{3}+...+a_{3n}x_{n}=b_{3} $$ dan akhirnya = \\(a^{(n-1)}_{nn}x_{n} = b^{(n-1)}_{n}\\) Substitusi Mundur Ketika sudah didapatkan persamaan yang akhir, lalu mencari nilai variable terakhir, caranya membagi konstanta dengan koefisien variabel itu sendiri \\(x_{n}=\\dfrac{b^{(n-1)}_{n}}{a^{(n-1)}_{nn}}\\) lalu substitusikan hasil (Xn) ke persamaan yang ada di atasnya Begini Alurnya : $$ \\begin{bmatrix} a_{11} & a_{12} & a_{13} \\vdots b_{1} \\ a_{21} & a_{22} & a_{23} \\vdots b_{2} \\ a_{31} & a_{32} & a_{33} \\vdots b_{3} \\end{bmatrix} \\rightarrow \\begin{aligned} R_{2}-\\dfrac{a_{21}}{a_{11}}R_{1} \\ R_{3}-\\dfrac{a_{21}}{a_{11}}R_{1} \\end{aligned} \\rightarrow $$ $$ \\rightarrow \\begin{bmatrix} a_{11} & a_{12} & a_{13} \\vdots b_{1} \\ 0 & a_{22} & a_{23} \\vdots b_{2} \\ 0 & a_{32} & a_{33} \\vdots b_{3} \\end{bmatrix} \\rightarrow \\begin{aligned}R_{3}-\\dfrac{a_{32}}{a_{22}}R_{1} \\end{aligned} \\rightarrow $$ $$ \\rightarrow \\begin{bmatrix} a_{11} & a_{12} & a_{13} \\vdots b_{1} \\ 0 & a_{22} & a_{23} \\vdots b_{2} \\ 0 & a_{32} & a_{33} \\vdots b_{3} \\end{bmatrix} $$ Dilakukan dari bawah $$ untuk \\space a \\space dan \\space b \\space aksen \\space 2 $$ $$ a_{33} \\vdots b_{3} \\rightarrow x_{3}=\\dfrac{b_{3}}{a_{33}} $$ $$ untuk \\space a \\space dan \\space b \\space aksen $$ $$ a_{22}a_{23} \\vdots b_{2} \\rightarrow a_{22}x_{2}+a_{23}x_{3}=b_{2} $$ $$ untuk \\space a \\space dan \\space b \\space aksen $$ $$ Kedua \\space diatas \\rightarrow x_{2}= \\dfrac{b_{2}-a_{23}x_{3}}{a_{22}} $$ $$ a_{11} a_{12} a_{13} \\vdots b_{1} \\rightarrow a_{11}x_{1}+a_{12}x_{2}+a_{13}x_{3}=b_{1} $$ $$ kedua \\space diatas \\rightarrow x_{1}= \\dfrac{b_{1}-a_{13}x_{3}-a_{12}x_{2}}{a_{11}} $$","title":"A. Eliminasi Gauss"},{"location":"materi-Solusi-Numerik/#b_eliminasi_gauss-jordan","text":"\u200b Metode eliminasi Gauss-Jordan adalah metode modifikasi dari Gauss, dimetode ini dilakukan normalisasi oleh pivot koefisiennya, maka dari itu akan menghasilkan matrix identitas. $$ \\begin{bmatrix} a_{11} & a_{12} & a_{13} \\vdots b_{1} \\ a_{21} & a_{22} & a_{23} \\vdots b_{2} \\ a_{31} & a_{32} & a_{33} \\vdots b_{3} \\end{bmatrix} \\rightarrow \\dfrac{R_{1}}{a_{11}} \\rightarrow $$ \\[ \\rightarrow \\begin{bmatrix} 1 & a'_{12} & a'_{13} \\vdots b'_{1} \\\\ a_{21} & a_{22} & a_{23} \\vdots b_{2} \\\\ a_{31} & a_{32} & a_{33} \\vdots b_{3} \\end{bmatrix} \\rightarrow \\begin{aligned} R_{2}-\\dfrac{a_{21}}{1}R_{1} \\\\ R_{3}- \\dfrac{a_{21}}{1}R_{1} \\end{aligned} \\rightarrow \\] \\[ \\rightarrow \\begin{bmatrix} 1 & a'_{12} & a'_{13} \\vdots b'_{1} \\\\ 0 & a'_{22} & a'_{23} \\vdots b'_{2} \\\\ 0 & a'_{32} & a'_{33} \\vdots b'_{3} \\end{bmatrix} \\rightarrow \\dfrac{R_{2}}{a'_{22}} \\rightarrow \\] \\[ \\rightarrow \\begin{bmatrix} 1 & a'_{12} & a'_{13} \\vdots b'_{1} \\\\ 0 & 1 & a''_{23} \\vdots b''_{2} \\\\ 0 & a'_{32} & a'_{33} \\vdots b'_{3} \\end{bmatrix} \\rightarrow \\begin{aligned} R_{1}-\\dfrac{a'_{12}}{1}R_{2} \\\\ R_{3}-\\dfrac{a'_{32}}{1}R_{2} \\end{aligned} \\rightarrow \\] \\[ \\rightarrow \\begin{bmatrix} 1 & 0 & a''_{13} \\vdots b''_{1} \\\\ 0 & 1 & a''_{23} \\vdots b''_{2} \\\\ 0 & 0 & a''_{33} \\vdots b''_{3} \\end{bmatrix} \\rightarrow \\dfrac{R_{3}}{a''_{33}} \\rightarrow \\] \\[ \\rightarrow \\begin{bmatrix} 1 & 0 & a''_{13} \\vdots b''_{1} \\\\ 0 & 1 & a''_{23} \\vdots b''_{2} \\\\ 0 & 0 & 1 \\vdots b''_{3} \\end{bmatrix} \\rightarrow \\begin{aligned} R_{2}-\\dfrac{a''_{23}}{1}R_{3} \\\\ R_{1}-\\dfrac{a''_{13}}{1}R_{3} \\end{aligned} \\rightarrow \\] \\[ \\rightarrow \\begin{bmatrix} 1 & 0 & 0 \\vdots b''_{1} \\\\ 0 & 1 & 0 \\vdots b''_{2} \\\\ 0 & 0 & 1 \\vdots b''_{3} \\end{bmatrix} \\rightarrow \\begin{aligned} x_{1}=b'''_{1} \\\\ x_{2}=b'''_{2} \\\\ x_{3}=b'''_{3} \\end{aligned} \\]","title":"B. Eliminasi Gauss-Jordan"},{"location":"materi-Solusi-Numerik/#c_gauss_-_siedel","text":"\u200b metode ini merupakan iterasi yang menggunakan asumsi matrix [A] [X] = [B] yang mempunyai batasan berupa matrix 3x3, pada diagonal elemetnya tidak sama dengan 0, pada persamaannya mempunyai sifat konvergen. \\[ \\begin{aligned} a_{11}x_{1} + a_{12}x_{2}+a_{13}x_{3}=b_{1} \\\\ a_{21}x_{1} + a_{22}x_{2}+a_{23}x_{3}=b_{2} \\\\ a_{31}x_{1} + a_{32}x_{2}+a_{33}x_{3}=b_{3} \\end{aligned} \\rightarrow \\begin{aligned} x_{1}=\\dfrac{b_{1}-a_{13}x_{3}-a_{12}x_{2}}{a_{11}} \\\\ x_{2}=\\dfrac{b_{2}-a_{21}x_{1}-a_{23}x_{3}}{a_{22}} \\\\ x_{3}=\\dfrac{b_{3}-a_{31}x_{1}-a_{32}x_{2}}{a_{33}} \\end{aligned} \\] Iterasi Pertama : Mencari X1 dengan X2 = 0 dan X3 = 0 \\[ X_{1}=\\dfrac{b_{1}-a_{13}x_{3}-a_{12}x_{2}}{a_{11}} \\rightarrow x_{1}=\\dfrac {b_{1}}{a_{11}} \\] Mencari X2 dengan X3 = 0 dan X1 (baru) \\[ X_{2}=\\dfrac{b_{2}-a_{21}x_{1}-a_{23}x_{3}}{a_{22}} \\rightarrow x_{2}=\\dfrac {b_{2}-a_{21}x_{1}}{a_{22}} \\] mencari X3 dengan X2(baru) dan X1 (baru) \\[ X_{3}=\\dfrac{b_{3}-a_{31}x_{1}-a_{32}x_{2}}{a_{33}} \\] Iterasi Kedua: Mencari X1 dengan X3 (baru) dan X2 (baru) \\[ X_{1}=\\dfrac{b_{1}-a_{13}x_{3}-a_{12}x_{2}}{a_{11}} \\] Menacari X2 dengan X1 (baru) dan X3 (baru) \\[ X_{2}=\\dfrac{b_{2}-a_{21}x_{1}-a_{23}x_{3}}{a_{22}} \\] Mencari X3 dengan X2 (baru) dan X1 (baru) \\[ X_{3}=\\dfrac{b_{3}-a_{31}x_{1}-a_{32}x_{2}}{a_{33}} \\]","title":"C. Gauss - Siedel"},{"location":"materi-Solusi-Numerik/#d_dekomposisi_lu","text":"\u200b Merupakan metode dengan matrix yang ada di kiri [A] akan dimanipulasi sehingga menjadi matrix lower ([L]) dan matrix upper ([U]). metode ini adalah kombinasi dari Gauss dan Gauss-Jordan dengan","title":"D. Dekomposisi LU"},{"location":"materi-integrasi-numerik/","text":"Integrasi Numerik \u00b6 \u200b Pentingnya integrasi numerik dalam mengungkapkan masalah didalam bidang sains lebih tepatnya dalam mengungkapkan integral matematis yang sangat sulit untuk diselesaikan secara analitis. Beberapa integral juga mengandung beberapa titik - titik data. Berikut adalah penjelasan mengenai integrasi numerik yang sangat umum digunakan untuk menemukan pendekatan integral fungsi y(x) pada batas interval [a,b]. umumnya integral tersebut dapat dinyatakan dengan $$ I = \\int ^{b}_{x=a}f(x)dx $$ \u200b Rumus diatas adalah integral fungsi y(x) terhadap terhadap x bebas yang dievaluasi dari x = a hingga x = b. perubahan tersebut dapat dinyatakan sebagai \\[ I(x) = \\Sigma^{N}_{i=1}w_{i}y(x_{i}) \\] N adalah jumlah segmen, \\(y(x_{1}) = y(_{a})\\) dan \\(y(_{x_{N}}) = y(_{b})\\) \u200b Diatas adalah jumlahan dari deret suku - suku dengan titik - titik xi terbentang dari x=a hingga x=b lalu pada setiap titik xi dievaluasi oleh fungsi y(x). Xi disebut sebagai Node / Fungsi , lalu wi disebut faktor bobot. - Metode Trapezoida \u00b6 \u200b Metode Trapezoida adalah suatu proses untuk mencari nilai fungsi dari f(x) dengan batas (x = x0 ke xn) dengan menggunakan persamaan kondisi non-equispaced dan kondisi equispaced. trapezoida mempunyai batasan dalam mencari luasan, y = f(x) dan sumbu x dibagi oleh N pada range x = [a, b] yang dinyatakan dalam trapesium untuk dihitung. Persamaan Non-Equispaced \u00b6 Persamaan ini adalah persamaan yang memiliki selisih pada setiap spasinya itu berbeda \\[ \\int f(x)dx = \\dfrac{\\left( x_{1}-x_{0}\\right) }{2} (f_{1} + f_{0})+\\dfrac{\\left( x_{2}-x_{1}\\right)}{2}(f_{2}+f_{1}) + ... + \\dfrac{\\left( x_{n} - x_{n-1}\\right) } {2}(f_{n} +f_{n-1}) \\] Persamaan Equispaced \u00b6 Persamaan ini adalah persamaan yang memiliki selisih pada setiap spasinya itu sama \\[ \\int f(x)dx = \\dfrac{h}{2}[f_{0}+2(f_{1}+f_{2}+f_{3}+...+f_{n-1}) + f_{n}] \\] - Metode Simpson \u00b6 Metode simpson adalah sebuah metode dalam integrasi numerik yang merupakan pengembangan dari metode Trapezoida. yang membedakan adalah sebuah pembaginya, Yaitu bukan menggunakan trapesium, akan tetapi menggunakan dua buah trapesium. yang digunakan adalah bobot berat dari titik tengahnya. metode ini juga sering disebut metode rata - rata dengan bobot yang digunakan adalah kuadrat. Simpson 1/3 \u00b6 Integrasi numerik ini dengan menggunakan error dari metode yang akan dihitung dengan persamaan dibawah ini. \\[ \\int f(x)dx=\\dfrac{h}{3}[f_{0} + 4(f_{1}+f_{3}+f_{5}+ ... + f_{n-1}) + 2(f_{2}+f_{4}+f_{6}+ ... + f_{n-2}) + f_{n}] \\] Simpson 3/8 \u00b6 Sama halnya dengan simpson 1/3, namun error metodenya yang akan dihitung adalah dengan persamaan dibawah ini. \\[ \\int f(x)dx=\\dfrac{3h}{8}[f_{0} + 3(f_{1}+f_{2}+f_{4}+f_{5}+ ... + f_{n-1}) + 2(f_{3}+f_{6}+f_{9}+ ... + f_{n-3}) + f_{n}] \\] - Metode Integrasi Kuadratur \u00b6 metode ini adalah metode yang sangat simple untuk digunakan, menggunakan metode ini adalah dengan mengevaluasi fungsi pada sejumlah lokasi lalu hasilnya digunakan untuk menghampiri integral tersebut. titik yang sudah di tentukan tersebut oromatis sudah sesuai dengan faktor bobotnya. lalu hanya perlu menjumlahkannya \\[ I = \\int ^{N}_{i=0}w_{i}f(x_{i}) \\] xi merupakan titik evaluasi dan wi merupakan bobot yang bersesuaian dengan titik ke-i. untuk menerapkannya perlu beberapa pendekatan terhadap sebuah integral, perlunya evaluasi pada dalam menentukan titik dan faktor yang bersesuaian tersebut. antara lain dengan memenuhi fungsi - fungsi integral lain \\[ \\begin{aligned} f(x) = 1 \\\\f(x)=x \\\\f(x)=x^2 \\end{aligned} \\] dengan mensubstitusi fungsi pada persemaan, maka akan memberikan persamaan simultan didalam wi yang dapat menjadi beberapa faktor bobot. Contoh : untuk f(x) =1 \\[ w_{1}f(x_{1})+w_{2}f(x_{2}) = \\int ^{1}_{-1}1dx = 2 = w_{1} + w_{2} \\] untuk f(x)= x \\[ w_{1}f(x_{1})+w_{2}f(x_{2}) = \\int ^{1}_{-1}x dx = 0 = w_{1}x_{1} + w_{2}x_{2} \\] untuk f(x) = \\(x^{2}\\) \\[ w_{1}f(x_{1})+w_{2}f(x_{2}) = \\int ^{1}_{-1}x^2dx = \\dfrac{2}{3} = w_{1}x^2_{1} + w_{2}x^2_{2} \\] untuk f(x) = \\(x^{3}\\) \\[ w_{1}f(x_{1})+w_{2}f(x_{2}) = \\int ^{1}_{-1}x^3 dx = 0 = w_{1}x^3_{1} + w_{2}x^3_{2} \\] persamaan simultan sudah didapat, yaitu \\[ \\begin{aligned} w_{1}+w_{2} = 2 \\\\ w_{1}x_{1} + w_{2}x_{2} = 0 \\\\w_{1}x^2_{1} + w_{2}x^2_{2} = \\dfrac{2}{3} \\\\w_{1}x^3_{1} + w_{2}x^3_{2} = 0 \\end{aligned} \\] lalu, jika simultan - simultas di atas diselesaikan, maka diperoleh sebagai berikut: \\[ \\begin{aligned} w_{1}=w_{2}=1 \\\\x_{1}=-\\dfrac{1}{\\sqrt{3}}= -0,5773503 \\\\x_{1}=\\dfrac{1}{\\sqrt{3}}= 0,5773503 \\end{aligned} \\] degan mensubstitusinya maka akan menjadi \\[ I= f\\left(-\\dfrac{1}{\\sqrt{3}}\\right) + f\\left(\\dfrac{1}{\\sqrt{3}}\\right) \\] selanjutnya tinggal mencari faktor bobot yang berdekatan dan bersesuaian dengan integrasi gauss 3 titik. persamaan itu harus memenuhi sebagai berikut untuk f(x)=1 \\[ w_{1}f(x_{1}) + w_{2}f(x_{2})+w_{3}f(x_{3}) = \\int ^1_{-1} 1dx = 2 = w_{1} + w_{2} + w_{3} \\] untuk f(x) = x \\[ w_{1}f(x_{1}) + w_{2}f(x_{2})+w_{3}f(x_{3}) = \\int ^1_{-1} xdx = 0 = w_{1}x_{1} + w_{2}x_{2} + w_{3}x_{3} \\] untuk f(x) = \\(x_{2}\\) \\[ w_{1}f(x_{1}) + w_{2}f(x_{2})+w_{3}f(x_{3}) = \\int ^1_{-1} x^2dx = \\dfrac{2}{3} = w_{1}x^2_{1} + w_{2}x^2_{2} + w_{3}x^2_{3} \\] untuk f(x) = \\(x^{3}\\) \\[ w_{1}f(x_{1}) + w_{2}f(x_{2})+w_{3}f(x_{3}) = \\int ^1_{-1} x^3 dx = 0 = w_{1}x^3_{1} + w_{2}x^3_{2} + w_{3}x^3_{3} \\] untuk f(x) = \\(x^{4}\\) \\[ w_{1}f(x_{1}) + w_{2}f(x_{2})+w_{3}f(x_{3}) = \\int ^1_{-1} x^4dx = \\dfrac{2}{5} = w_{1}x^4_{1} + w_{2}x^4_{2} + w_{3}x^4_{3} \\] untuk f(x) = \\(x^{5}\\) \\[ w_{1}f(x_{1}) + w_{2}f(x_{2})+w_{3}f(x_{3}) = \\int ^1_{-1} x^5 dx = 0 = w_{1}x^5_{1} + w_{2}x^5_{2} + w_{3}x^5_{3} \\] dapat diperoleh persamaan simultan sebagai berikut: \\[ \\begin{aligned} w_{1} + w_{2} + w_{3} = 2 \\\\ w_{1}x_{1} + w_{2}x_{2} + w_{3}x_{3} = 0 \\\\ w_{1}x^2_{1} + w_{2}x^2_{2} + w_{3}x^2_{3} = \\dfrac{2}{3} \\\\ w_{1}x^3_{1} + w_{2}x^3_{2} + w_{3}x^3_{3} = 0 \\\\ w_{1}x^4_{1} + w_{2}x^4_{2} + w_{3}x^4_{3} = \\dfrac{2}{5} \\\\ w_{1}x^5_{1} + w_{2}x^5_{2} + w_{3}x^5_{3} = 0 \\end{aligned} \\] dengan menyelesaikan diatas, maka hasil untuk titik - titik dan faktor bobot yang bersesuaian yaitu : x1 = -0,774596669 w1 = 0,555555559 x2 = 0 w2 = 0,888888889 x3 = 0,774596669 w3 = 0,555555559 Bahwa metode kuadratur ini adalah memperhatikan batas - batas integrasi yang terpenuhi -1 hinggai +1. hal ini yang membuat metode ini kurang bebas. perlu dilakukan tranformasi kepada batas bawah dan atas integrasinya. karenanya harus ada hubungan natara x1 dengan x $$ x = \\dfrac{2x_{t} - a - b}{b - a} $$ xt merupakan koordinat origin yang ada dalam interval [a, b] atau a<x1<b. lalu x merupakan koordinat ternormalisasi yang ada dalam range -1<x<1. tranformasi ini yang dilalui dari x ke x1 $$ x_{t}=\\dfrac{(b-a)x+a+b}{2} $$ dengan ungkapan tranformasi, maka integral dapat dinyatakan $$ \\int^b_{a}f(x_{t})dx_{t}=\\int^1_{-1}f(x_{t})(dx_{t}/dx)dx\u2248\\dfrac{b-a}{2}\\Sigma^N_{i=1}w_{i}f(x_{t_{i}}) $$ dimana $$ \\dfrac{dx_{t}}{dx}=\\dfrac{(b-a)}{2} $$ NIlai dari xti didapatkan dengan mensubstitusi x dengan titik - titik Gauss $$ x_{t_{i}} = \\dfrac{(b-a)x_{i}+a+b}{2} $$ - Metode Rieman \u00b6 \u200b Metode ini adalah metode yang dilakukan dengan cara membagi interval pada bawah kurva disuatu fungsi sebanyak m subintervalnya yang sama besar. lalu pada setiap subinterval tersebut, dibentuk menyerupai persegi panjang yang tingginya sama dengan kutva di setiap titik tengahnya. Untuk area subintervalnya, diperoleh dengan cara mengalikan panjang serta lebar pada setiap persegi panjang. lalu pada hasil area tersebut yang digunakan untuk menaksir interval tersebut, metode ini dilakukan menyerupai metode titik tengah \\[ \\int^{b}_{a}f(x)dx\\approx \\Sigma ^{m}_{i=1}f\\left(i\\dfrac{|b - a|}{m}- \\dfrac{|b-a|}{2m}\\right)\\dfrac{|b-a|}{m} \\] pada b dan a adlaah masing masing batas, yaitu batas atas dan batas bawah sebuah interval kurva yang akan dihitung integralnya. lalu Error dari metode ini dapat menggunakan rumus sebagai berikut : $$ \\begin{aligned} \\int^{b}_{a}h(x)dx=-\\dfrac{(b-a)^{3}}{24m^{2}}f^{(2)}\\xi\\ \\\\xi \\space adalah \\space nilai \\space antara \\space a \\space dan \\space b \\end{aligned} $$","title":"Materi"},{"location":"materi-integrasi-numerik/#integrasi_numerik","text":"\u200b Pentingnya integrasi numerik dalam mengungkapkan masalah didalam bidang sains lebih tepatnya dalam mengungkapkan integral matematis yang sangat sulit untuk diselesaikan secara analitis. Beberapa integral juga mengandung beberapa titik - titik data. Berikut adalah penjelasan mengenai integrasi numerik yang sangat umum digunakan untuk menemukan pendekatan integral fungsi y(x) pada batas interval [a,b]. umumnya integral tersebut dapat dinyatakan dengan $$ I = \\int ^{b}_{x=a}f(x)dx $$ \u200b Rumus diatas adalah integral fungsi y(x) terhadap terhadap x bebas yang dievaluasi dari x = a hingga x = b. perubahan tersebut dapat dinyatakan sebagai \\[ I(x) = \\Sigma^{N}_{i=1}w_{i}y(x_{i}) \\] N adalah jumlah segmen, \\(y(x_{1}) = y(_{a})\\) dan \\(y(_{x_{N}}) = y(_{b})\\) \u200b Diatas adalah jumlahan dari deret suku - suku dengan titik - titik xi terbentang dari x=a hingga x=b lalu pada setiap titik xi dievaluasi oleh fungsi y(x). Xi disebut sebagai Node / Fungsi , lalu wi disebut faktor bobot.","title":"Integrasi Numerik"},{"location":"materi-integrasi-numerik/#-_metode_trapezoida","text":"\u200b Metode Trapezoida adalah suatu proses untuk mencari nilai fungsi dari f(x) dengan batas (x = x0 ke xn) dengan menggunakan persamaan kondisi non-equispaced dan kondisi equispaced. trapezoida mempunyai batasan dalam mencari luasan, y = f(x) dan sumbu x dibagi oleh N pada range x = [a, b] yang dinyatakan dalam trapesium untuk dihitung.","title":"- Metode Trapezoida"},{"location":"materi-integrasi-numerik/#persamaan_non-equispaced","text":"Persamaan ini adalah persamaan yang memiliki selisih pada setiap spasinya itu berbeda \\[ \\int f(x)dx = \\dfrac{\\left( x_{1}-x_{0}\\right) }{2} (f_{1} + f_{0})+\\dfrac{\\left( x_{2}-x_{1}\\right)}{2}(f_{2}+f_{1}) + ... + \\dfrac{\\left( x_{n} - x_{n-1}\\right) } {2}(f_{n} +f_{n-1}) \\]","title":"Persamaan Non-Equispaced"},{"location":"materi-integrasi-numerik/#persamaan_equispaced","text":"Persamaan ini adalah persamaan yang memiliki selisih pada setiap spasinya itu sama \\[ \\int f(x)dx = \\dfrac{h}{2}[f_{0}+2(f_{1}+f_{2}+f_{3}+...+f_{n-1}) + f_{n}] \\]","title":"Persamaan Equispaced"},{"location":"materi-integrasi-numerik/#-_metode_simpson","text":"Metode simpson adalah sebuah metode dalam integrasi numerik yang merupakan pengembangan dari metode Trapezoida. yang membedakan adalah sebuah pembaginya, Yaitu bukan menggunakan trapesium, akan tetapi menggunakan dua buah trapesium. yang digunakan adalah bobot berat dari titik tengahnya. metode ini juga sering disebut metode rata - rata dengan bobot yang digunakan adalah kuadrat.","title":"- Metode Simpson"},{"location":"materi-integrasi-numerik/#simpson_13","text":"Integrasi numerik ini dengan menggunakan error dari metode yang akan dihitung dengan persamaan dibawah ini. \\[ \\int f(x)dx=\\dfrac{h}{3}[f_{0} + 4(f_{1}+f_{3}+f_{5}+ ... + f_{n-1}) + 2(f_{2}+f_{4}+f_{6}+ ... + f_{n-2}) + f_{n}] \\]","title":"Simpson 1/3"},{"location":"materi-integrasi-numerik/#simpson_38","text":"Sama halnya dengan simpson 1/3, namun error metodenya yang akan dihitung adalah dengan persamaan dibawah ini. \\[ \\int f(x)dx=\\dfrac{3h}{8}[f_{0} + 3(f_{1}+f_{2}+f_{4}+f_{5}+ ... + f_{n-1}) + 2(f_{3}+f_{6}+f_{9}+ ... + f_{n-3}) + f_{n}] \\]","title":"Simpson 3/8"},{"location":"materi-integrasi-numerik/#-_metode_integrasi_kuadratur","text":"metode ini adalah metode yang sangat simple untuk digunakan, menggunakan metode ini adalah dengan mengevaluasi fungsi pada sejumlah lokasi lalu hasilnya digunakan untuk menghampiri integral tersebut. titik yang sudah di tentukan tersebut oromatis sudah sesuai dengan faktor bobotnya. lalu hanya perlu menjumlahkannya \\[ I = \\int ^{N}_{i=0}w_{i}f(x_{i}) \\] xi merupakan titik evaluasi dan wi merupakan bobot yang bersesuaian dengan titik ke-i. untuk menerapkannya perlu beberapa pendekatan terhadap sebuah integral, perlunya evaluasi pada dalam menentukan titik dan faktor yang bersesuaian tersebut. antara lain dengan memenuhi fungsi - fungsi integral lain \\[ \\begin{aligned} f(x) = 1 \\\\f(x)=x \\\\f(x)=x^2 \\end{aligned} \\] dengan mensubstitusi fungsi pada persemaan, maka akan memberikan persamaan simultan didalam wi yang dapat menjadi beberapa faktor bobot. Contoh : untuk f(x) =1 \\[ w_{1}f(x_{1})+w_{2}f(x_{2}) = \\int ^{1}_{-1}1dx = 2 = w_{1} + w_{2} \\] untuk f(x)= x \\[ w_{1}f(x_{1})+w_{2}f(x_{2}) = \\int ^{1}_{-1}x dx = 0 = w_{1}x_{1} + w_{2}x_{2} \\] untuk f(x) = \\(x^{2}\\) \\[ w_{1}f(x_{1})+w_{2}f(x_{2}) = \\int ^{1}_{-1}x^2dx = \\dfrac{2}{3} = w_{1}x^2_{1} + w_{2}x^2_{2} \\] untuk f(x) = \\(x^{3}\\) \\[ w_{1}f(x_{1})+w_{2}f(x_{2}) = \\int ^{1}_{-1}x^3 dx = 0 = w_{1}x^3_{1} + w_{2}x^3_{2} \\] persamaan simultan sudah didapat, yaitu \\[ \\begin{aligned} w_{1}+w_{2} = 2 \\\\ w_{1}x_{1} + w_{2}x_{2} = 0 \\\\w_{1}x^2_{1} + w_{2}x^2_{2} = \\dfrac{2}{3} \\\\w_{1}x^3_{1} + w_{2}x^3_{2} = 0 \\end{aligned} \\] lalu, jika simultan - simultas di atas diselesaikan, maka diperoleh sebagai berikut: \\[ \\begin{aligned} w_{1}=w_{2}=1 \\\\x_{1}=-\\dfrac{1}{\\sqrt{3}}= -0,5773503 \\\\x_{1}=\\dfrac{1}{\\sqrt{3}}= 0,5773503 \\end{aligned} \\] degan mensubstitusinya maka akan menjadi \\[ I= f\\left(-\\dfrac{1}{\\sqrt{3}}\\right) + f\\left(\\dfrac{1}{\\sqrt{3}}\\right) \\] selanjutnya tinggal mencari faktor bobot yang berdekatan dan bersesuaian dengan integrasi gauss 3 titik. persamaan itu harus memenuhi sebagai berikut untuk f(x)=1 \\[ w_{1}f(x_{1}) + w_{2}f(x_{2})+w_{3}f(x_{3}) = \\int ^1_{-1} 1dx = 2 = w_{1} + w_{2} + w_{3} \\] untuk f(x) = x \\[ w_{1}f(x_{1}) + w_{2}f(x_{2})+w_{3}f(x_{3}) = \\int ^1_{-1} xdx = 0 = w_{1}x_{1} + w_{2}x_{2} + w_{3}x_{3} \\] untuk f(x) = \\(x_{2}\\) \\[ w_{1}f(x_{1}) + w_{2}f(x_{2})+w_{3}f(x_{3}) = \\int ^1_{-1} x^2dx = \\dfrac{2}{3} = w_{1}x^2_{1} + w_{2}x^2_{2} + w_{3}x^2_{3} \\] untuk f(x) = \\(x^{3}\\) \\[ w_{1}f(x_{1}) + w_{2}f(x_{2})+w_{3}f(x_{3}) = \\int ^1_{-1} x^3 dx = 0 = w_{1}x^3_{1} + w_{2}x^3_{2} + w_{3}x^3_{3} \\] untuk f(x) = \\(x^{4}\\) \\[ w_{1}f(x_{1}) + w_{2}f(x_{2})+w_{3}f(x_{3}) = \\int ^1_{-1} x^4dx = \\dfrac{2}{5} = w_{1}x^4_{1} + w_{2}x^4_{2} + w_{3}x^4_{3} \\] untuk f(x) = \\(x^{5}\\) \\[ w_{1}f(x_{1}) + w_{2}f(x_{2})+w_{3}f(x_{3}) = \\int ^1_{-1} x^5 dx = 0 = w_{1}x^5_{1} + w_{2}x^5_{2} + w_{3}x^5_{3} \\] dapat diperoleh persamaan simultan sebagai berikut: \\[ \\begin{aligned} w_{1} + w_{2} + w_{3} = 2 \\\\ w_{1}x_{1} + w_{2}x_{2} + w_{3}x_{3} = 0 \\\\ w_{1}x^2_{1} + w_{2}x^2_{2} + w_{3}x^2_{3} = \\dfrac{2}{3} \\\\ w_{1}x^3_{1} + w_{2}x^3_{2} + w_{3}x^3_{3} = 0 \\\\ w_{1}x^4_{1} + w_{2}x^4_{2} + w_{3}x^4_{3} = \\dfrac{2}{5} \\\\ w_{1}x^5_{1} + w_{2}x^5_{2} + w_{3}x^5_{3} = 0 \\end{aligned} \\] dengan menyelesaikan diatas, maka hasil untuk titik - titik dan faktor bobot yang bersesuaian yaitu : x1 = -0,774596669 w1 = 0,555555559 x2 = 0 w2 = 0,888888889 x3 = 0,774596669 w3 = 0,555555559 Bahwa metode kuadratur ini adalah memperhatikan batas - batas integrasi yang terpenuhi -1 hinggai +1. hal ini yang membuat metode ini kurang bebas. perlu dilakukan tranformasi kepada batas bawah dan atas integrasinya. karenanya harus ada hubungan natara x1 dengan x $$ x = \\dfrac{2x_{t} - a - b}{b - a} $$ xt merupakan koordinat origin yang ada dalam interval [a, b] atau a<x1<b. lalu x merupakan koordinat ternormalisasi yang ada dalam range -1<x<1. tranformasi ini yang dilalui dari x ke x1 $$ x_{t}=\\dfrac{(b-a)x+a+b}{2} $$ dengan ungkapan tranformasi, maka integral dapat dinyatakan $$ \\int^b_{a}f(x_{t})dx_{t}=\\int^1_{-1}f(x_{t})(dx_{t}/dx)dx\u2248\\dfrac{b-a}{2}\\Sigma^N_{i=1}w_{i}f(x_{t_{i}}) $$ dimana $$ \\dfrac{dx_{t}}{dx}=\\dfrac{(b-a)}{2} $$ NIlai dari xti didapatkan dengan mensubstitusi x dengan titik - titik Gauss $$ x_{t_{i}} = \\dfrac{(b-a)x_{i}+a+b}{2} $$","title":"- Metode Integrasi Kuadratur"},{"location":"materi-integrasi-numerik/#-_metode_rieman","text":"\u200b Metode ini adalah metode yang dilakukan dengan cara membagi interval pada bawah kurva disuatu fungsi sebanyak m subintervalnya yang sama besar. lalu pada setiap subinterval tersebut, dibentuk menyerupai persegi panjang yang tingginya sama dengan kutva di setiap titik tengahnya. Untuk area subintervalnya, diperoleh dengan cara mengalikan panjang serta lebar pada setiap persegi panjang. lalu pada hasil area tersebut yang digunakan untuk menaksir interval tersebut, metode ini dilakukan menyerupai metode titik tengah \\[ \\int^{b}_{a}f(x)dx\\approx \\Sigma ^{m}_{i=1}f\\left(i\\dfrac{|b - a|}{m}- \\dfrac{|b-a|}{2m}\\right)\\dfrac{|b-a|}{m} \\] pada b dan a adlaah masing masing batas, yaitu batas atas dan batas bawah sebuah interval kurva yang akan dihitung integralnya. lalu Error dari metode ini dapat menggunakan rumus sebagai berikut : $$ \\begin{aligned} \\int^{b}_{a}h(x)dx=-\\dfrac{(b-a)^{3}}{24m^{2}}f^{(2)}\\xi\\ \\\\xi \\space adalah \\space nilai \\space antara \\space a \\space dan \\space b \\end{aligned} $$","title":"- Metode Rieman"},{"location":"material-for-mkdocs/","text":"Material for MkDocs \u00b6 MkDocs \u00b6 mkdocs/mkdocs: Project documentation with Markdown - GitHub Material for MkDocs \u00b6 squidfunk/mkdocs-material: A Material Design theme for MkDocs","title":"Material for MkDocs"},{"location":"material-for-mkdocs/#material_for_mkdocs","text":"","title":"Material for MkDocs"},{"location":"material-for-mkdocs/#mkdocs","text":"mkdocs/mkdocs: Project documentation with Markdown - GitHub","title":"MkDocs"},{"location":"material-for-mkdocs/#material_for_mkdocs_1","text":"squidfunk/mkdocs-material: A Material Design theme for MkDocs","title":"Material for MkDocs"},{"location":"extensions/code-hilite/","text":"CodeHilite \u00b6 CodeHilite - Material for MkDocs Supported languages - Pygments Configure mkdocs.yml \u00b6 markdown_extensions: - codehilite","title":"CodeHilite"},{"location":"extensions/code-hilite/#codehilite","text":"CodeHilite - Material for MkDocs Supported languages - Pygments","title":"CodeHilite"},{"location":"extensions/code-hilite/#configure_mkdocsyml","text":"markdown_extensions: - codehilite","title":"Configure mkdocs.yml"},{"location":"extensions/footnote/","text":"Footnote \u00b6 Footnotes - Material for MkDocs Configure mkdocs.yml \u00b6 markdown_extensions: - footnotes Example \u00b6 Footnote example 1. 1 Footnote example 2. 2 One line \u21a9 First line Second line \u21a9","title":"Footnote"},{"location":"extensions/footnote/#footnote","text":"Footnotes - Material for MkDocs","title":"Footnote"},{"location":"extensions/footnote/#configure_mkdocsyml","text":"markdown_extensions: - footnotes","title":"Configure mkdocs.yml"},{"location":"extensions/footnote/#example","text":"Footnote example 1. 1 Footnote example 2. 2 One line \u21a9 First line Second line \u21a9","title":"Example"},{"location":"extensions/mathjax/","text":"MathJax \u00b6 PyMdown - Material for MkDocs Configure mkdocs.yml \u00b6 markdown_extensions: - mdx_math: enable_dollar_delimiter: True Example code \u00b6 $$ P \\c dot Q = \\| P \\|\\| Q \\|\\c os \\a lpha $$ Example rendering \u00b6 \\[ P\\cdot Q = \\|P\\|\\|Q\\|\\cos\\alpha \\]","title":"MathJax"},{"location":"extensions/mathjax/#mathjax","text":"PyMdown - Material for MkDocs","title":"MathJax"},{"location":"extensions/mathjax/#configure_mkdocsyml","text":"markdown_extensions: - mdx_math: enable_dollar_delimiter: True","title":"Configure mkdocs.yml"},{"location":"extensions/mathjax/#example_code","text":"$$ P \\c dot Q = \\| P \\|\\| Q \\|\\c os \\a lpha $$","title":"Example code"},{"location":"extensions/mathjax/#example_rendering","text":"\\[ P\\cdot Q = \\|P\\|\\|Q\\|\\cos\\alpha \\]","title":"Example rendering"},{"location":"getting-started/docker/","text":"Start with Docker \u00b6 Public docker image \u00b6 Package mkdocs-material - GitHub peaceiris/mkdocs-material - Docker Hub docker-compose \u00b6 Here is an example docker-compose.yml Please check the latest tag before you go. docker-compose up Go to http://localhost:8000/","title":"Start with Docker"},{"location":"getting-started/docker/#start_with_docker","text":"","title":"Start with Docker"},{"location":"getting-started/docker/#public_docker_image","text":"Package mkdocs-material - GitHub peaceiris/mkdocs-material - Docker Hub","title":"Public docker image"},{"location":"getting-started/docker/#docker-compose","text":"Here is an example docker-compose.yml Please check the latest tag before you go. docker-compose up Go to http://localhost:8000/","title":"docker-compose"},{"location":"getting-started/download-boilerplate/","text":"Download boilerplate \u00b6 Git clone \u00b6 git clone https://github.com/peaceiris/mkdocs-material-boilerplate.git cd mkdocs-material-boilerplate Download zip \u00b6 wget 'https://github.com/peaceiris/mkdocs-material-boilerplate/archive/main.zip' unzip main.zip cd mkdocs-material-boilerplate-main \ud83d\udc49 Click me to download zip","title":"Download boilerplate"},{"location":"getting-started/download-boilerplate/#download_boilerplate","text":"","title":"Download boilerplate"},{"location":"getting-started/download-boilerplate/#git_clone","text":"git clone https://github.com/peaceiris/mkdocs-material-boilerplate.git cd mkdocs-material-boilerplate","title":"Git clone"},{"location":"getting-started/download-boilerplate/#download_zip","text":"wget 'https://github.com/peaceiris/mkdocs-material-boilerplate/archive/main.zip' unzip main.zip cd mkdocs-material-boilerplate-main \ud83d\udc49 Click me to download zip","title":"Download zip"},{"location":"getting-started/invoke/","text":"Serve and open with invoke \u00b6 invoke \u00b6 Invoke is a Python (2.7 and 3.4+) library for managing shell-oriented subprocesses and organizing executable Python code into CLI-invokable tasks. It draws inspiration from various sources (make/rake, Fabric 1.x, etc) to arrive at a powerful & clean feature set. pyinvoke/invoke: Pythonic task management & command execution. Serve and open \u00b6 Run mkdocs serve and open browser automatically. inv serve Serving on localhost:8000 # set IP and port inv serve --dev-addr 'localhost:5000' # set config file inv serve --config-file ./mkdocs-sample.yml Show all tasks \u00b6 $ inv --list Available tasks: serve Serve site and open browser Show task help. $ inv serve --help Usage: inv [ oke ] [ --core-opts ] serve [ --options ] [ other tasks here ... ] Docstring: Serve site and open browser Options: -c STRING, --config-file = STRING Provide a specific MkDocs config -d STRING, --dev-addr = STRING IP address and port to serve documentation locally ( default: localhost:8000 ) Tasks are defined by tasks.py","title":"Serve and open with invoke"},{"location":"getting-started/invoke/#serve_and_open_with_invoke","text":"","title":"Serve and open with invoke"},{"location":"getting-started/invoke/#invoke","text":"Invoke is a Python (2.7 and 3.4+) library for managing shell-oriented subprocesses and organizing executable Python code into CLI-invokable tasks. It draws inspiration from various sources (make/rake, Fabric 1.x, etc) to arrive at a powerful & clean feature set. pyinvoke/invoke: Pythonic task management & command execution.","title":"invoke"},{"location":"getting-started/invoke/#serve_and_open","text":"Run mkdocs serve and open browser automatically. inv serve Serving on localhost:8000 # set IP and port inv serve --dev-addr 'localhost:5000' # set config file inv serve --config-file ./mkdocs-sample.yml","title":"Serve and open"},{"location":"getting-started/invoke/#show_all_tasks","text":"$ inv --list Available tasks: serve Serve site and open browser Show task help. $ inv serve --help Usage: inv [ oke ] [ --core-opts ] serve [ --options ] [ other tasks here ... ] Docstring: Serve site and open browser Options: -c STRING, --config-file = STRING Provide a specific MkDocs config -d STRING, --dev-addr = STRING IP address and port to serve documentation locally ( default: localhost:8000 ) Tasks are defined by tasks.py","title":"Show all tasks"},{"location":"getting-started/pip/","text":"Start with pip (Anaconda, Miniconda) \u00b6 pip install -r requirements.txt pip install -r requirements-dev.txt inv command is also available.","title":"Start with pip (Anaconda, Miniconda)"},{"location":"getting-started/pip/#start_with_pip_anaconda_miniconda","text":"pip install -r requirements.txt pip install -r requirements-dev.txt inv command is also available.","title":"Start with pip (Anaconda, Miniconda)"},{"location":"getting-started/pipenv/","text":"Start with pipenv \u00b6 pipenv \u00b6 Pipenv is a tool that aims to bring the best of all packaging worlds (bundler, composer, npm, cargo, yarn, etc.) to the Python world. pypa/pipenv: Python Development Workflow for Humans. Install all packages \u00b6 pipenv sync --dev # Installs all packages specified in Pipfile.lock. Run MkDocs \u00b6 pipenv shell # Spawns a shell within the virtualenv. mkdocs serve Or, run mkdocs with pipenv run pipenv run mkdocs serve pipenv run \u00b6 pipenv task are also defined by Pipfile pipenv run version # mkdocs --version pipenv run help # mkdocs --help pipenv run inv serve # inv serve pipenv run serve # mkdocs serve pipenv run build # mkdocs build pipenv run deploy # mkdocs gh-deploy","title":"Start with pipenv"},{"location":"getting-started/pipenv/#start_with_pipenv","text":"","title":"Start with pipenv"},{"location":"getting-started/pipenv/#pipenv","text":"Pipenv is a tool that aims to bring the best of all packaging worlds (bundler, composer, npm, cargo, yarn, etc.) to the Python world. pypa/pipenv: Python Development Workflow for Humans.","title":"pipenv"},{"location":"getting-started/pipenv/#install_all_packages","text":"pipenv sync --dev # Installs all packages specified in Pipfile.lock.","title":"Install all packages"},{"location":"getting-started/pipenv/#run_mkdocs","text":"pipenv shell # Spawns a shell within the virtualenv. mkdocs serve Or, run mkdocs with pipenv run pipenv run mkdocs serve","title":"Run MkDocs"},{"location":"getting-started/pipenv/#pipenv_run","text":"pipenv task are also defined by Pipfile pipenv run version # mkdocs --version pipenv run help # mkdocs --help pipenv run inv serve # inv serve pipenv run serve # mkdocs serve pipenv run build # mkdocs build pipenv run deploy # mkdocs gh-deploy","title":"pipenv run"},{"location":"hosting-and-deployment/aws-amplify-console/","text":"Host on AWS Amplify Console \u00b6 AWS Amplify Console You can use Password protection each branch. Use the following build specification YML file. mkdocs-material-boilerplate/amplify.yml","title":"Host on AWS Amplify Console"},{"location":"hosting-and-deployment/aws-amplify-console/#host_on_aws_amplify_console","text":"AWS Amplify Console You can use Password protection each branch. Use the following build specification YML file. mkdocs-material-boilerplate/amplify.yml","title":"Host on AWS Amplify Console"},{"location":"hosting-and-deployment/combinations/","text":"Hosting and Deployment \u00b6 GitHub Pages and GitHub \u00b6 Host source code on GitHub. Build and deploy with: mkdocs gh-deploy GitHub Actions GitLab Pages and GitLab \u00b6 Host source code on GitLab. Build and deploy with GitLab CI/CD. Netlify \u00b6 Host source code on: GitHub GitLab BitBucket Build and deploy with Netlify. AWS Amplify Console \u00b6 Host source code on: GitHub GitLab BitBucket AWS CodeCommit Build and deploy with AWS Amplify Console.","title":"Hosting and Deployment"},{"location":"hosting-and-deployment/combinations/#hosting_and_deployment","text":"","title":"Hosting and Deployment"},{"location":"hosting-and-deployment/combinations/#github_pages_and_github","text":"Host source code on GitHub. Build and deploy with: mkdocs gh-deploy GitHub Actions","title":"GitHub Pages and GitHub"},{"location":"hosting-and-deployment/combinations/#gitlab_pages_and_gitlab","text":"Host source code on GitLab. Build and deploy with GitLab CI/CD.","title":"GitLab Pages and GitLab"},{"location":"hosting-and-deployment/combinations/#netlify","text":"Host source code on: GitHub GitLab BitBucket Build and deploy with Netlify.","title":"Netlify"},{"location":"hosting-and-deployment/combinations/#aws_amplify_console","text":"Host source code on: GitHub GitLab BitBucket AWS CodeCommit Build and deploy with AWS Amplify Console.","title":"AWS Amplify Console"},{"location":"hosting-and-deployment/github-pages/","text":"Host on GitHub Pages \u00b6 Demo site on GitHub Pages (build & deploy with GitHub Actions) Build and deploy with GitHub Actions \u00b6 peaceiris/actions-gh-pages: GitHub Actions for deploying to GitHub Pages with Static Site Generators Go to the repository and read the latest README.md for more details. Build and deploy with mkdocs gh-deploy \u00b6 pipenv \u00b6 pipenv run deploy # OR pipenv shell mkdocs gh-deploy # OR pipenv run mkdocs gh-deploy","title":"Host on GitHub Pages"},{"location":"hosting-and-deployment/github-pages/#host_on_github_pages","text":"Demo site on GitHub Pages (build & deploy with GitHub Actions)","title":"Host on GitHub Pages"},{"location":"hosting-and-deployment/github-pages/#build_and_deploy_with_github_actions","text":"peaceiris/actions-gh-pages: GitHub Actions for deploying to GitHub Pages with Static Site Generators Go to the repository and read the latest README.md for more details.","title":"Build and deploy with GitHub Actions"},{"location":"hosting-and-deployment/github-pages/#build_and_deploy_with_mkdocs_gh-deploy","text":"","title":"Build and deploy with mkdocs gh-deploy"},{"location":"hosting-and-deployment/github-pages/#pipenv","text":"pipenv run deploy # OR pipenv shell mkdocs gh-deploy # OR pipenv run mkdocs gh-deploy","title":"pipenv"},{"location":"hosting-and-deployment/gitlab-pages/","text":"Host on GitLab Pages \u00b6 See .gitlab-ci.yml","title":"Host on GitLab Pages"},{"location":"hosting-and-deployment/gitlab-pages/#host_on_gitlab_pages","text":"See .gitlab-ci.yml","title":"Host on GitLab Pages"},{"location":"hosting-and-deployment/netlify/","text":"Host on Netlify \u00b6 Demo site on Netlify (build & deploy with Netlify) Create GitHub repository and deploy to Netlify with the following button in 1 min.","title":"Host on Netlify"},{"location":"hosting-and-deployment/netlify/#host_on_netlify","text":"Demo site on Netlify (build & deploy with Netlify) Create GitHub repository and deploy to Netlify with the following button in 1 min.","title":"Host on Netlify"}]}